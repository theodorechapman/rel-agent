import * as fs from 'node:fs';

/**
 * Utility types and helper functions
 */
/**
 * Recipient type
 *
 * Can be one of the following formats:
 * - Phone number
 * - Email address
 */
type Recipient = string;
/**
 * Validate recipient format
 *
 * Supported formats:
 * - Phone number: +1234567890, (123) 456-7890
 * - Email address: user@example.com
 *
 * @param value Recipient string (phone or email)
 * @returns Validated recipient
 * @throws TypeError when format is invalid
 */
declare const asRecipient: (value: string) => Recipient;
/**
 * Predicate function
 * Returns whether a condition is met
 */
type Predicate<T> = (value: T) => boolean;
/**
 * Mapper function
 * Transforms type T to type U
 */
type Mapper<T, U> = (value: T) => U;

/**
 * Message related types
 */
/**
 * Message service type
 *
 * - iMessage: Apple's iMessage service
 * - SMS: Traditional SMS service
 * - RCS: Rich Communication Services
 */
type ServiceType = 'iMessage' | 'SMS' | 'RCS';
/**
 * Message attachment information
 *
 * Contains file metadata and local path
 */
interface Attachment {
    /** Unique ID of the attachment in database */
    readonly id: string;
    /** Filename */
    readonly filename: string;
    /** MIME type (e.g. image/jpeg) */
    readonly mimeType: string;
    /** Full local path to the file */
    readonly path: string;
    /** File size in bytes */
    readonly size: number;
    /** Whether this is an image type */
    readonly isImage: boolean;
    /** Attachment creation time */
    readonly createdAt: Date;
}
/**
 * Message object
 *
 * Represents a complete iMessage/SMS message
 */
interface Message {
    /** Unique ID of the message in database */
    readonly id: string;
    /** Globally unique identifier for the message */
    readonly guid: string;
    /** Message text content (null for non-text messages) */
    readonly text: string | null;
    /** Sender identifier (phone number or email) */
    readonly sender: string;
    /** Sender display name (may be null) */
    readonly senderName: string | null;
    /** ID of the chat this message belongs to */
    readonly chatId: string;
    /** Whether this is a group chat message */
    readonly isGroupChat: boolean;
    /** Message service type */
    readonly service: ServiceType;
    /** Whether the message is read */
    readonly isRead: boolean;
    /** Whether the message is sent by me */
    readonly isFromMe: boolean;
    /** List of attachments (readonly array) */
    readonly attachments: readonly Attachment[];
    /** Message sent/received time */
    readonly date: Date;
}
/**
 * Message query filter
 *
 * All fields are optional, used to filter messages
 */
interface MessageFilter {
    /** Only query unread messages */
    readonly unreadOnly?: boolean;
    /** Exclude messages sent by current user (default: true) */
    readonly excludeOwnMessages?: boolean;
    /** Filter by sender */
    readonly sender?: string;
    /** Filter by chat ID */
    readonly chatId?: string;
    /** Filter by service type */
    readonly service?: ServiceType;
    /** Only query messages with attachments */
    readonly hasAttachments?: boolean;
    /** Only query messages after this time */
    readonly since?: Date;
    /** Search message text content (case-insensitive) */
    readonly search?: string;
    /** Limit number of results */
    readonly limit?: number;
}
/**
 * Message query result
 *
 * Contains message list and statistics
 */
interface MessageQueryResult {
    /** List of messages */
    readonly messages: readonly Message[];
    /** Total number of messages found */
    readonly total: number;
    /** Number of unread messages */
    readonly unreadCount: number;
}
/**
 * Unread messages result
 *
 * Contains unread messages grouped by sender with statistics
 */
interface UnreadMessagesResult {
    /** Messages grouped by sender */
    readonly groups: ReadonlyArray<{
        readonly sender: string;
        readonly messages: readonly Message[];
    }>;
    /** Total number of unread messages */
    readonly total: number;
    /** Number of unique senders */
    readonly senderCount: number;
}
/**
 * Options for listing chats
 */
interface ListChatsOptions {
    /** Maximum number of chats to return */
    limit?: number;
    /** Filter by chat type */
    type?: 'all' | 'group' | 'dm';
    /** Only return chats with unread messages */
    hasUnread?: boolean;
    /** Sort order */
    sortBy?: 'recent' | 'name';
    /** Search by display name (case-insensitive) */
    search?: string;
}
/**
 * Chat summary information
 *
 * Used by sdk.listChats() to help developers discover chatId
 */
interface ChatSummary {
    /** Chat identifier (e.g., 'iMessage;+1234567890' or group guid) */
    readonly chatId: string;
    /** Display name (group name or contact name); may be null */
    readonly displayName: string | null;
    /** Time of the last message in this chat; may be null */
    readonly lastMessageAt: Date | null;
    /** Whether this chat is a group */
    readonly isGroup: boolean;
    /** Number of unread messages in this chat */
    readonly unreadCount: number;
}

/**
 * Plugin System
 *
 * Plugins can listen to the following lifecycle hooks:
 * - SDK initialization and destruction
 * - Before and after message queries
 * - Before and after sending messages
 * - When new messages are received
 * - When errors occur
 */

/**
 * Plugin lifecycle hooks
 */
interface PluginHooks {
    /** Called when SDK initialization is complete */
    onInit?: () => void | Promise<void>;
    /** Called before querying messages (useful for logging) */
    onBeforeQuery?: (filter: unknown) => void | Promise<void>;
    /** Called after querying messages (useful for data processing) */
    onAfterQuery?: (messages: readonly Message[]) => void | Promise<void>;
    /** Called before sending a message (useful for validation, logging) */
    onBeforeSend?: (to: string, content: {
        text?: string;
        attachments?: string[];
    }) => void | Promise<void>;
    /** Called after sending a message (useful for logging results) */
    onAfterSend?: (to: string, result: SendResult) => void | Promise<void>;
    /** Called when a new message is received (triggered by listener) */
    onNewMessage?: (message: Message) => void | Promise<void>;
    /** Called when an error occurs (global error handling) */
    onError?: (error: Error, context?: string) => void | Promise<void>;
    /** Called when SDK is destroyed (cleanup resources) */
    onDestroy?: () => void | Promise<void>;
}
/**
 * Plugin metadata
 */
interface PluginMetadata {
    /** Unique plugin name */
    readonly name: string;
    /** Plugin version number (optional) */
    readonly version?: string;
    /** Plugin description (optional) */
    readonly description?: string;
}
/**
 * Complete plugin interface
 * Plugin = metadata + hook functions
 */
interface Plugin extends PluginMetadata, PluginHooks {
}
/**
 * Plugin manager
 */
declare class PluginManager {
    /** List of registered plugins */
    private plugins;
    /** Whether the plugin manager has been initialized */
    initialized: boolean;
    /**
     * Register a plugin
     * If the manager is already initialized, the plugin's onInit hook will be called immediately
     * @param plugin Plugin instance
     * @returns this - Supports method chaining
     */
    use(plugin: Plugin): this;
    /**
     * Initialize all plugins
     * Calls the onInit hook for all plugins
     */
    init(): Promise<void>;
    /**
     * Destroy all plugins
     * Calls the onDestroy hook for all plugins and clears the plugin list
     */
    destroy(): Promise<void>;
    /**
     * Call the specified hook for all plugins
     * @param hookName Hook name
     * @param args Hook arguments
     * @returns List of plugin errors (if any)
     */
    callHookForAll<K extends keyof PluginHooks>(hookName: K, ...args: Parameters<NonNullable<PluginHooks[K]>>): Promise<Array<{
        plugin: string;
        error: Error;
    }>>;
}
/**
 * Helper function to define a plugin
 */
declare const definePlugin: (plugin: Plugin) => Plugin;

/**
 * SDK configuration types
 */

/**
 * Webhook notification configuration
 *
 * Used to send HTTP notifications when new messages are received
 */
interface WebhookConfig {
    /** Webhook URL address */
    readonly url: string;
    /** Custom HTTP headers */
    readonly headers?: Record<string, string>;
    /** Request timeout in milliseconds (default: 5000) */
    readonly timeout?: number;
    /**
     * Retry attempts when webhook POST fails (default: 0)
     * Set to a small number (e.g., 1-3) to improve reliability
     */
    readonly retries?: number;
    /**
     * Backoff delay between retries in milliseconds (default: 0)
     * Example: 500 means wait 500ms before the next retry
     */
    readonly backoffMs?: number;
}
/**
 * Message watcher configuration
 *
 * Controls message polling behavior
 */
interface WatcherConfig {
    /** Poll interval in milliseconds (default: 2000) */
    readonly pollInterval?: number;
    /** Only watch unread messages (default: false) */
    readonly unreadOnly?: boolean;
    /** Exclude messages sent by current user (default: true) */
    readonly excludeOwnMessages?: boolean;
}
/**
 * Retry configuration
 *
 * Controls retry behavior when message sending fails
 */
interface RetryConfig {
    /** Maximum retry attempts (default: 2) */
    readonly max?: number;
    /** Base retry delay in milliseconds (default: 1500) */
    readonly delay?: number;
}
/**
 * Temporary file configuration
 *
 * Controls cleanup behavior for temporary files created when sending attachments
 */
interface TempFileConfig {
    /** File retention time in milliseconds (default: 10 minutes) */
    readonly maxAge?: number;
    /** Cleanup interval in milliseconds (default: 5 minutes) */
    readonly cleanupInterval?: number;
}
/**
 * SDK main configuration interface
 *
 * All options are optional and use default values
 */
interface IMessageConfig {
    /**
     * Database path
     * Default: ~/Library/Messages/chat.db
     */
    readonly databasePath?: string;
    /** Webhook configuration (optional) */
    readonly webhook?: WebhookConfig;
    /** Watcher configuration (optional) */
    readonly watcher?: WatcherConfig;
    /** Retry configuration (optional) */
    readonly retry?: RetryConfig;
    /** Temporary file configuration (optional) */
    readonly tempFile?: TempFileConfig;
    /**
     * AppleScript execution timeout
     * In milliseconds (default: 30000)
     */
    readonly scriptTimeout?: number;
    /**
     * Maximum concurrent sends
     * Default: 5, 0 means unlimited
     */
    readonly maxConcurrent?: number;
    /** Debug mode (default: false) */
    readonly debug?: boolean;
    /** Plugin list (optional) */
    readonly plugins?: readonly Plugin[];
}
/**
 * Resolved configuration
 *
 * All fields are populated with default values, guaranteed non-null
 */
interface ResolvedConfig {
    readonly databasePath: string;
    readonly webhook: WebhookConfig | null;
    readonly watcher: Required<WatcherConfig>;
    readonly retry: Required<RetryConfig>;
    readonly tempFile: Required<TempFileConfig>;
    readonly scriptTimeout: number;
    readonly maxConcurrent: number;
    readonly debug: boolean;
}

/**
 * Message Promise
 *
 * Tracks outgoing messages and resolves when they appear in the database
 */

interface MessagePromiseOptions {
    chatId: string;
    text?: string;
    attachmentName?: string;
    isAttachment: boolean;
    sentAt: Date | number;
    debug?: boolean;
}
/**
 * Promise wrapper for tracking outgoing messages
 */
declare class MessagePromise {
    promise: Promise<Message>;
    private resolvePromise;
    private rejectPromise;
    readonly chatId: string;
    readonly text: string;
    readonly attachmentName: string | null;
    readonly isAttachment: boolean;
    readonly sentAt: number;
    private readonly debug;
    isResolved: boolean;
    errored: boolean;
    error: any;
    private timeoutHandle;
    constructor(options: MessagePromiseOptions);
    /**
     * Normalize text for comparison
     * Only remove whitespace and convert to lowercase for case-insensitive matching
     * Keep all other characters including Unicode (Chinese, emoji, etc.)
     */
    private normalizeText;
    /**
     * Get filename without extension
     */
    private getFilenameWithoutExtension;
    /**
     * Resolve the promise with the sent message
     */
    resolve(message: Message): void;
    /**
     * Reject the promise with an error
     */
    reject(reason: string, message?: Message): void;
    /**
     * Check if this promise matches the given message
     */
    matches(message: Message): boolean;
    /**
     * Check if chat ID matches (handles different formats)
     */
    private matchesChatId;
    /**
     * Normalize chat ID for comparison
     *
     * Handles format differences between what we construct and what's in the database:
     *
     * Database stores (from message.chatId):
     * - DM: "pilot@photon.codes" (no prefix)
     * - Group: "chat493787071395575843" (no prefix)
     *
     * We construct (in sender.ts):
     * - DM: "iMessage;-;pilot@photon.codes"
     * - Group: "iMessage;+;chat493787071395575843" or just the GUID
     *
     * This method extracts the core identifier (last part after semicolons) to ensure
     * both formats match correctly. For example:
     * - "iMessage;-;pilot@photon.codes" → "pilot@photon.codes"
     * - "pilot@photon.codes" → "pilot@photon.codes"
     * Both normalize to the same value, enabling successful matching.
     */
    private normalizeChatId;
}

/**
 * Outgoing Message Manager
 *
 * Manages all pending outgoing messages and matches them with database entries
 */

declare class OutgoingMessageManager {
    private promises;
    private debug;
    constructor(debug?: boolean);
    /**
     * Add a new message promise to track
     */
    add(promise: MessagePromise): void;
    /**
     * Try to match and resolve a message promise
     * Returns true if a match was found
     */
    tryResolve(message: Message): boolean;
    /**
     * Clean up resolved promises (older than 1 minute)
     */
    cleanup(): void;
    /**
     * Get count of pending promises
     */
    getPendingCount(): number;
    /**
     * Reject all pending promises (used when closing SDK)
     */
    rejectAll(reason?: string): void;
}

/**
 * Message Sender
 */

/** Send result */
interface SendResult {
    readonly sentAt: Date;
    /** The sent message (only available if watcher is running and message was confirmed) */
    readonly message?: Message;
}
/** Send options */
interface SendOptions {
    /** Recipient */
    readonly to: string | Recipient;
    /** Text content */
    readonly text?: string;
    /** Attachments */
    readonly attachments?: readonly string[];
    /** Abort signal (optional) */
    readonly signal?: AbortSignal;
}
/** Send options for group chat */
interface SendToGroupOptions {
    /** Group chat identifier (GUID) */
    readonly groupId: string;
    /** Text content */
    readonly text?: string;
    /** Attachments */
    readonly attachments?: readonly string[];
    /** Abort signal (optional) */
    readonly signal?: AbortSignal;
}
/**
 * Message Sender Class
 */
declare class MessageSender {
    /** Debug mode */
    private readonly debug;
    /** Maximum retry attempts */
    private readonly maxRetries;
    /** Retry delay */
    private readonly retryDelay;
    /** Concurrency limiter */
    private readonly semaphore;
    /** AppleScript timeout */
    private readonly scriptTimeout;
    /** Outgoing message manager */
    private outgoingManager;
    constructor(debug?: boolean, retryConfig?: Required<RetryConfig>, maxConcurrent?: number, scriptTimeout?: number);
    /**
     * Set outgoing message manager (called by SDK)
     */
    setOutgoingManager(manager: OutgoingMessageManager): void;
    /**
     * Execute script with retry
     *
     * @param script AppleScript code
     * @param description Operation description
     * @returns Execution result
     */
    private executeWithRetry;
    /**
     * Resolve attachment path
     * - Download network images (HTTP URL) → ~/Pictures/imsg_temp_*
     * - Validate local file path
     * - Auto-convert incompatible formats (AVIF/WebP -> JPEG) → ~/Pictures/imsg_temp_*
     *
     * Note: All temporary files are automatically named imsg_temp_* and stored in ~/Pictures
     *       TempFileManager will automatically scan and clean up these files, no manual tracking needed
     *
     * @param path Attachment path (local path or HTTP URL)
     * @returns Local path
     */
    private resolveAttachment;
    /**
     * Send message to recipient
     */
    send(options: SendOptions): Promise<SendResult>;
    /**
     * Check abort signal
     */
    private checkAbortSignal;
    /**
     * Check Messages environment
     */
    private checkMessagesEnvironment;
    /**
     * Prepare all attachments (download, convert)
     */
    private prepareAttachments;
    /**
     * Send to recipient using buddy method
     */
    private sendToRecipient;
    /**
     * Send to group using chat id method
     */
    private sendToGroupChat;
    /**
     * Send message to group chat
     */
    sendToGroup(options: SendToGroupOptions): Promise<SendResult>;
}

/**
 * Message Processing Chain
 */

/**
 * Message Processing Chain
 *
 * Note: You must explicitly call execute() to perform operations
 *
 * @example
 * ```ts
 * await sdk.message(msg)
 *   .ifFromOthers()
 *   .matchText('hello')
 *   .replyText('Hi!')
 *   .execute()  // Must call execute()
 * ```
 */
declare class MessageChain {
    /** Message */
    private readonly message;
    /** Sender */
    private readonly sender;
    /** Whether to execute */
    private shouldExecute;
    /** Actions */
    private actions;
    /** Whether already executed */
    private executed;
    constructor(
    /** Message */
    message: Message, 
    /** Sender */
    sender: MessageSender);
    /**
     * Conditional check
     */
    when(predicate: Predicate<Message>): this;
    /**
     * Match text pattern
     */
    matchText(pattern: string | RegExp): this;
    /**
     * Only process unread messages
     */
    ifUnread(): this;
    /**
     * Only process messages from others
     */
    ifFromOthers(): this;
    /**
     * Only process my own messages
     */
    ifFromMe(): this;
    /**
     * Only process group chat messages
     */
    ifGroupChat(): this;
    /**
     * Reply with text
     *
     * Automatically routes to recipient or group based on message.chatId
     */
    replyText(text: string | Mapper<Message, string>): this;
    /**
     * Reply with image
     *
     * Automatically routes to recipient or group based on message.chatId
     */
    replyImage(images: string | string[] | Mapper<Message, string | string[]>): this;
    /**
     * Execute custom operation
     */
    do(handler: (message: Message) => void | Promise<void>): this;
    /**
     * Execute all operations (explicit call)
     *
     * This is the only method that actually performs operations
     *
     * @throws If an error occurs during execution
     */
    execute(): Promise<void>;
}

/**
 * SDK Error Types
 */
/** Error code types */
type ErrorCode = 'PLATFORM' | 'DATABASE' | 'SEND' | 'WEBHOOK' | 'CONFIG' | 'UNKNOWN';
/**
 * Unified SDK Error Class
 */
declare class IMessageError extends Error {
    readonly code: ErrorCode;
    constructor(code: ErrorCode, message: string, options?: ErrorOptions);
    /** Type guard */
    static is(error: unknown): error is IMessageError;
    /** Check if error is of specific type */
    is(code: ErrorCode): boolean;
}
/** Factory functions */
declare const PlatformError: (msg?: string, cause?: Error) => IMessageError;
declare const DatabaseError: (msg: string, cause?: Error) => IMessageError;
declare const SendError: (msg: string, cause?: Error) => IMessageError;
declare const WebhookError: (msg: string, cause?: Error) => IMessageError;
declare const ConfigError: (msg: string, cause?: Error) => IMessageError;

/**
 * Read-only access to macOS Messages app SQLite database
 */
declare class IMessageDatabase {
    /** SQLite database instance */
    private db;
    /** macOS epoch time (timestamp of 2001-01-01) */
    private readonly MAC_EPOCH;
    /** Initialization promise */
    private initPromise;
    /**
     * Open iMessage database
     * @param path Database file path
     * @throws DatabaseError When database fails to open
     */
    constructor(path: string);
    /**
     * Initialize database (async)
     */
    private init;
    /**
     * Ensure database is initialized before any operation
     */
    private ensureInit;
    /**
     * Query messages (with multiple filter options)
     *
     * @param filter Filter conditions (optional)
     * @returns Message query result (includes message list and statistics)
     * @throws DatabaseError When query fails
     *
     * @example Query all unread messages
     * ```ts
     * const result = await db.getMessages({ unreadOnly: true })
     * ```
     *
     * @example Query messages from specific sender
     * ```ts
     * const result = await db.getMessages({
     *   sender: '+1234567890',
     *   limit: 20
     * })
     * ```
     *
     * @example Query recent messages with attachments
     * ```ts
     * const result = await db.getMessages({
     *   hasAttachments: true,
     *   since: new Date('2024-01-01'),
     *   limit: 10
     * })
     * ```
     */
    getMessages(filter?: MessageFilter): Promise<MessageQueryResult>;
    /**
     * Get unread messages grouped by sender
     *
     * @returns Object with grouped messages and total count
     *
     * @example
     * ```ts
     * const { grouped, total } = await db.getUnreadMessages()
     * for (const [sender, messages] of grouped) {
     *   console.log(`${sender}: ${messages.length} unread messages`)
     * }
     * console.log(`Total: ${total}`)
     * ```
     */
    getUnreadMessages(): Promise<{
        grouped: Map<string, Message[]>;
        total: number;
    }>;
    /**
     * List chats with filtering and sorting options
     *
     * @param options Filter and sort options
     * @returns Array of chat summaries with unread counts
     *
     * @example
     * ```ts
     * // Get recent group chats with unread messages
     * const chats = await db.listChats({
     *   type: 'group',
     *   hasUnread: true,
     *   limit: 20
     * })
     * ```
     */
    listChats(options?: ListChatsOptions): Promise<ChatSummary[]>;
    /**
     * Get all attachments for specified message
     * @param messageId Message ID
     * @returns Array of attachments, returns empty array if no attachments
     */
    private getAttachments;
    /**
     * Decode XML entities in a string
     * @param text Text with XML entities
     * @returns Decoded text
     */
    private decodeXmlEntities;
    /**
     * Extract text from attributedBody (binary plist format)
     * @param attributedBody Binary plist data
     * @returns Extracted text or null if extraction fails
     */
    private extractTextFromAttributedBody;
    /**
     * Convert database query result to Message object
     * @param row Raw row data from database query
     * @returns Formatted Message object
     */
    private rowToMessage;
    /**
     * Map service type string from database
     * @param service Service identifier from database
     * @returns Standardized service type
     */
    private mapService;
    /**
     * Convert macOS timestamp to JavaScript Date object
     *
     * macOS epoch starts at 2001-01-01, unit is nanoseconds
     * @param timestamp macOS timestamp
     * @returns JavaScript Date object
     */
    private convertMacTimestamp;
    /**
     * Close database connection
     */
    close(): Promise<void>;
}

/**
 * Message Watcher
 */

/** Message callback */
type MessageCallback = (message: Message) => void | Promise<void>;
/** Watcher event callbacks */
interface WatcherEvents {
    /** Triggered when any new message arrives (DM or group) */
    onMessage?: MessageCallback;
    /** Triggered when new direct message arrives */
    onDirectMessage?: MessageCallback;
    /** Triggered when new group message arrives */
    onGroupMessage?: MessageCallback;
    /** Triggered when error occurs */
    onError?: (error: Error) => void;
}

/**
 * IMessage SDK - Type-safe macOS iMessage SDK
 *
 * @example
 * ```typescript
 * import { IMessageSDK, loggerPlugin } from '@photon-ai/imessage-kit'
 *
 * const sdk = new IMessageSDK({
 *   plugins: [loggerPlugin()]
 * })
 *
 * /// Send messages
 * await sdk.send('+1234567890', 'Hello!')
 * await sdk.send('+1234567890', { images: ['photo.jpg'] })
 *
 * /// Chain processing
 * await sdk.message(msg)
 *   .ifFromOthers()
 *   .matchText('hello')
 *   .replyText('Hi!')
 *   .execute()
 * ```
 */

/** SDK dependency injection interface */
interface SDKDependencies {
    database?: IMessageDatabase;
    sender?: MessageSender;
    pluginManager?: PluginManager;
}
/** IMessage SDK Core Class */
declare class IMessageSDK {
    /** Configuration */
    private readonly config;
    /** Database */
    private readonly database;
    /** Temporary file manager */
    private readonly tempFileManager;
    /** Message sender */
    private readonly sender;
    /** Plugin manager */
    private readonly pluginManager;
    /** Message watcher */
    private watcher;
    /** Outgoing message manager */
    private readonly outgoingManager;
    /** Whether destroyed */
    private destroyed;
    constructor(config?: IMessageConfig, dependencies?: SDKDependencies);
    private ensurePluginsReady;
    private resolveConfig;
    /**
     * Determine if a string is a chatId (not a recipient)
     *
     * ChatId formats:
     * - Group GUID: `chat123...`
     * - AppleScript group: `iMessage;+;chat123...`
     *
     * Recipient formats:
     * - Phone: `+1234567890`
     * - Email: `user@example.com`
     *
     * Note: `iMessage;+1234567890` is NOT a chatId for routing purposes.
     * It's a service-prefixed recipient that should be sent via buddy method.
     */
    private isChatId;
    /**
     * Register plugin
     */
    use(plugin: Plugin): this;
    /**
     * Get plugin manager
     * @returns PluginManager instance
     */
    get plugins(): PluginManager;
    /**
     * Query messages
     */
    getMessages(filter?: MessageFilter): Promise<MessageQueryResult>;
    /**
     * Get unread messages (grouped by sender)
     *
     * @returns Unread messages with statistics
     * @example
     * ```ts
     * const unread = await sdk.getUnreadMessages()
     * console.log(`${unread.total} unread messages from ${unread.senderCount} senders`)
     * for (const { sender, messages } of unread.groups) {
     *   console.log(`${sender}: ${messages.length} messages`)
     * }
     * ```
     */
    getUnreadMessages(): Promise<UnreadMessagesResult>;
    /**
     * Send message to recipient (phone/email) or chat (chatId)
     *
     * Automatically detects whether the target is:
     * - A recipient (phone number or email): e.g., '+1234567890', 'user@example.com'
     * - A chatId (group or DM): e.g., 'chat123...', 'iMessage;+1234567890'
     *
     * @example
     * ```ts
     * // Send to phone number
     * await sdk.send('+1234567890', 'Hello')
     *
     * // Send to email
     * await sdk.send('user@example.com', 'Hello')
     *
     * // Send to group chat
     * await sdk.send('chat123...', 'Hello')
     *
     * // Send with attachments
     * await sdk.send('+1234567890', { images: ['/img.jpg'] })
     * await sdk.send('chat123...', { text: 'Hi', files: ['/doc.pdf'] })
     * ```
     */
    send(to: string | Recipient, content: string | {
        text?: string;
        images?: string[];
        files?: string[];
    }): Promise<SendResult>;
    /**
     * List chats with filtering and sorting options
     *
     * @param options Filter and sort options (or a number for backward compatibility)
     * @returns Array of chat summaries with unread counts
     *
     * @example
     * ```ts
     * // Get all chats
     * const all = await sdk.listChats()
     *
     * // Get recent group chats with unread messages
     * const groups = await sdk.listChats({
     *   type: 'group',
     *   hasUnread: true,
     *   limit: 20
     * })
     *
     * // Search chats by name
     * const found = await sdk.listChats({
     *   search: 'John',
     *   sortBy: 'name'
     * })
     *
     * // Backward compatible: limit only
     * const recent = await sdk.listChats({ limit: 50 })
     * ```
     */
    listChats(options?: ListChatsOptions | number): Promise<ChatSummary[]>;
    /**
     * Send batch messages (concurrency controlled by sender's maxConcurrent config)
     *
     * @param messages Batch message list
     * @returns List of send results (including success and failure)
     *
     * @example
     * ```ts
     * const results = await sdk.sendBatch([
     *   { to: '+1234567890', content: 'Hello' },
     *   { to: '+0987654321', content: 'Hi' },
     * ])
     *
     * for (const result of results) {
     *   if (result.success) {
     *     console.log('Send success:', result.to)
     *   } else {
     *     console.error('Send failed:', result.to, result.error)
     *   }
     * }
     * ```
     */
    sendBatch(messages: Array<{
        to: string | Recipient;
        content: string | {
            text?: string;
            images?: string[];
            files?: string[];
        };
    }>): Promise<Array<{
        to: string;
        success: boolean;
        result?: SendResult;
        error?: Error;
    }>>;
    /**
     * Send file (convenience method)
     *
     * Supports both recipient (phone/email) and chatId
     *
     * @example
     * ```ts
     * // Send to phone number
     * await sdk.sendFile('+1234567890', '/path/to/document.pdf')
     *
     * // Send to group chat
     * await sdk.sendFile('chat123...', '/path/to/document.pdf', 'Here is the file')
     * ```
     */
    sendFile(to: string | Recipient, filePath: string, text?: string): Promise<SendResult>;
    /**
     * Send multiple files (convenience method)
     *
     * Supports both recipient (phone/email) and chatId
     *
     * @example
     * ```ts
     * // Send to phone number
     * await sdk.sendFiles('+1234567890', ['/file1.pdf', '/file2.csv'])
     *
     * // Send to group chat
     * await sdk.sendFiles('chat123...', ['/data.xlsx'], 'Check these files')
     * ```
     */
    sendFiles(to: string | Recipient, filePaths: string[], text?: string): Promise<SendResult>;
    /**
     * Create message processing chain
     */
    message(message: Message): MessageChain;
    /**
     * Start watching for new messages
     */
    startWatching(events?: WatcherEvents): Promise<void>;
    /**
     * Stop watching for new messages
     */
    stopWatching(): void;
    /**
     * Close SDK and release resources
     */
    close(): Promise<void>;
    /** Support using declaration (TypeScript 5.2+) */
    [Symbol.asyncDispose](): Promise<void>;
    /** Support using declaration (sync version) */
    [Symbol.dispose](): void;
}

/**
 * Logger Plugin
 */

/**
 * Log level
 */
type LogLevel = 'debug' | 'info' | 'warn' | 'error';
/**
 * Logger plugin options
 */
interface LoggerOptions {
    /** Log level (default: info) */
    level?: LogLevel;
    /** Whether to use colored output (default: true) */
    colored?: boolean;
    /** Whether to show timestamps (default: false) */
    timestamp?: boolean;
    /** Whether to log send operations (default: true) */
    logSend?: boolean;
    /** Whether to log new messages (default: false) */
    logNewMessage?: boolean;
}
/**
 * Create a logger plugin
 *
 * @param options Logger configuration (optional)
 * @returns Plugin instance
 *
 * @example Basic usage
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [loggerPlugin()]  // Use default configuration
 * })
 * ```
 *
 * @example Custom configuration
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [
 *     loggerPlugin({
 *       level: 'info',        // Only show info and above
 *       colored: true,        // Colored output
 *       timestamp: true,      // Show timestamps
 *       logSend: true,        // Log send operations
 *       logNewMessage: true   // Log new messages
 *     })
 *   ]
 * })
 * ```
 *
 * @example Production configuration
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [
 *     loggerPlugin({
 *       level: 'warn',        // Only show warnings and errors
 *       colored: false,       // Plain text output
 *       logSend: false        // Don't log send operations
 *     })
 *   ]
 * })
 * ```
 */
declare const loggerPlugin: (options?: LoggerOptions) => Plugin;

/**
 * Platform check utilities
 */

/**
 * Check and require running on macOS platform
 *
 * @throws PlatformError when not macOS
 */
declare const requireMacOS: () => void;
/**
 * Check if current system is macOS
 *
 * @returns true if macOS
 */
declare const isMacOS: () => boolean;

/**
 * Attachment Helper Functions
 *
 * Provides utility functions for working with message attachments
 * without adding methods to the Attachment interface (keeping it as pure data)
 */

/**
 * Check if attachment file exists on disk
 *
 * @param attachment Attachment object
 * @returns True if file exists, false otherwise
 *
 * @example
 * ```ts
 * import { attachmentExists } from '@photon-ai/imessage-kit/helpers'
 *
 * const attachment = message.attachments[0]
 * if (await attachmentExists(attachment)) {
 *   console.log('Attachment exists')
 * }
 * ```
 */
declare function attachmentExists(attachment: Attachment): Promise<boolean>;
/**
 * Download (copy) attachment to specified destination
 *
 * @param attachment Attachment object
 * @param destPath Destination file path
 * @throws Error if source file doesn't exist or copy fails
 *
 * @example
 * ```ts
 * import { downloadAttachment } from '@photon-ai/imessage-kit/helpers'
 *
 * const attachment = message.attachments[0]
 * await downloadAttachment(attachment, '/path/to/save/file.jpg')
 * ```
 */
declare function downloadAttachment(attachment: Attachment, destPath: string): Promise<void>;
/**
 * Get attachment file size in bytes
 *
 * @param attachment Attachment object
 * @returns File size in bytes, or 0 if file doesn't exist
 *
 * @example
 * ```ts
 * import { getAttachmentSize } from '@photon-ai/imessage-kit/helpers'
 *
 * const size = await getAttachmentSize(attachment)
 * console.log(`File size: ${(size / 1024 / 1024).toFixed(2)} MB`)
 * ```
 */
declare function getAttachmentSize(attachment: Attachment): Promise<number>;
/**
 * Get attachment metadata (size, modified time, etc.)
 *
 * @param attachment Attachment object
 * @returns File stats or null if file doesn't exist
 *
 * @example
 * ```ts
 * import { getAttachmentMetadata } from '@photon-ai/imessage-kit/helpers'
 *
 * const metadata = await getAttachmentMetadata(attachment)
 * if (metadata) {
 *   console.log(`Size: ${metadata.size}, Modified: ${metadata.mtime}`)
 * }
 * ```
 */
declare function getAttachmentMetadata(attachment: Attachment): Promise<fs.Stats | null>;
/**
 * Read attachment content as Buffer
 *
 * Useful for processing file contents without saving to disk
 *
 * @param attachment Attachment object
 * @returns File content as Buffer
 * @throws Error if file doesn't exist or read fails
 *
 * @example
 * ```ts
 * import { readAttachment } from '@photon-ai/imessage-kit/helpers'
 *
 * const buffer = await readAttachment(attachment)
 * // Process buffer...
 * ```
 */
declare function readAttachment(attachment: Attachment): Promise<Buffer>;
/**
 * Get attachment file extension
 *
 * @param attachment Attachment object
 * @returns File extension (without dot) or empty string
 *
 * @example
 * ```ts
 * import { getAttachmentExtension } from '@photon-ai/imessage-kit/helpers'
 *
 * const ext = getAttachmentExtension(attachment)
 * if (ext === 'jpg' || ext === 'png') {
 *   console.log('Image file')
 * }
 * ```
 */
declare function getAttachmentExtension(attachment: Attachment): string;
/**
 * Check if attachment is an image
 *
 * @param attachment Attachment object
 * @returns True if attachment is an image file
 *
 * @example
 * ```ts
 * import { isImageAttachment } from '@photon-ai/imessage-kit/helpers'
 *
 * if (isImageAttachment(attachment)) {
 *   console.log('This is an image')
 * }
 * ```
 */
declare function isImageAttachment(attachment: Attachment): boolean;
/**
 * Check if attachment is a video
 *
 * @param attachment Attachment object
 * @returns True if attachment is a video file
 */
declare function isVideoAttachment(attachment: Attachment): boolean;
/**
 * Check if attachment is an audio file
 *
 * @param attachment Attachment object
 * @returns True if attachment is an audio file
 */
declare function isAudioAttachment(attachment: Attachment): boolean;

export { type Attachment, type ChatSummary, ConfigError, DatabaseError, type ErrorCode, type IMessageConfig, IMessageError, IMessageSDK, type ListChatsOptions, type LoggerOptions, type Mapper, type Message, MessageChain, type MessageFilter, type MessageQueryResult, PlatformError, type Plugin, type PluginHooks, type Predicate, type Recipient, type ResolvedConfig, type RetryConfig, SendError, type SendOptions, type SendResult, type SendToGroupOptions, type ServiceType, type TempFileConfig, type UnreadMessagesResult, type WatcherConfig, type WatcherEvents, type WebhookConfig, WebhookError, asRecipient, attachmentExists, definePlugin, downloadAttachment, getAttachmentExtension, getAttachmentMetadata, getAttachmentSize, isAudioAttachment, isImageAttachment, isMacOS, isVideoAttachment, loggerPlugin, readAttachment, requireMacOS };
