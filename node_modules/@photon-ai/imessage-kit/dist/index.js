import * as fs from 'fs';
import { existsSync, readdirSync, statSync, unlinkSync, writeFileSync } from 'fs';
import { homedir, tmpdir } from 'os';
import * as path from 'path';
import { join, resolve } from 'path';
import { exec } from 'child_process';
import { writeFile, unlink } from 'fs/promises';
import { promisify } from 'util';

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/types/advanced.ts
var PHONE_REGEX = /^\+?[\d\s\-()]+$/;
var hasMinDigits = (str2, min) => {
  const digits = str2.replace(/\D/g, "");
  return digits.length >= min;
};
var EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
var URL_REGEX = /^https?:\/\/.+/;
var asRecipient = (value) => {
  const normalized = value.trim();
  if (!normalized) {
    throw new TypeError("Recipient cannot be empty");
  }
  if (EMAIL_REGEX.test(normalized)) {
    return normalized;
  }
  if (PHONE_REGEX.test(normalized) && hasMinDigits(normalized, 7)) {
    return normalized;
  }
  throw new TypeError(`Invalid recipient format: ${value} (phone number or email required)`);
};
var isURL = (value) => {
  return URL_REGEX.test(value);
};

// src/utils/common.ts
var delay = (ms) => {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
};
function validateMessageContent(text, attachments) {
  const hasText = Boolean(text && text.trim().length > 0);
  const hasAttachments = Boolean(attachments && attachments.length > 0);
  if (!hasText && !hasAttachments) {
    throw new Error("Message must contain text or attachments");
  }
  return { hasText, hasAttachments };
}
function isGroupChatId(chatId) {
  if (chatId.startsWith("iMessage;+;chat")) {
    return true;
  }
  if (!chatId.includes(";") && chatId.startsWith("chat") && chatId.length > 10) {
    return true;
  }
  return false;
}
function extractRecipientFromChatId(chatId) {
  if (!chatId.includes(";")) {
    return null;
  }
  if (isGroupChatId(chatId)) {
    return null;
  }
  const parts = chatId.split(";");
  if (parts.length === 2) {
    return parts[1] || null;
  }
  return null;
}
function validateChatId(chatId) {
  if (!chatId || typeof chatId !== "string") {
    throw new Error("chatId must be a non-empty string");
  }
  if (chatId.includes(";")) {
    const parts = chatId.split(";");
    if (parts.length >= 3 && parts[0] === "iMessage" && parts[1] === "+" && parts[2]?.startsWith("chat")) {
      const guidPart = parts.slice(2).join(";");
      if (guidPart.length < 8) {
        throw new Error("Invalid chatId format: GUID too short");
      }
      return;
    }
    const service = parts[0] || "";
    const address = parts[1] || "";
    const allowedServices = /* @__PURE__ */ new Set(["iMessage", "SMS", "RCS"]);
    if (!allowedServices.has(service) || !address) {
      throw new Error('Invalid chatId format: expected "<service>;<address>" or group GUID');
    }
    return;
  }
  if (chatId.length < 8) {
    throw new Error("Invalid chatId format: GUID too short");
  }
}

// src/core/chain.ts
var MessageChain = class {
  constructor(message, sender) {
    this.message = message;
    this.sender = sender;
    if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
      setTimeout(() => {
        if (!this.executed && this.actions.length > 0) {
          console.warn(
            "[MessageChain] Warning: Unexecuted message chain detected.",
            "You need to explicitly call .execute() method.\n",
            `Message ID: ${this.message.id}, Sender: ${this.message.sender}`
          );
        }
      }, 1e3);
    }
  }
  /** Whether to execute */
  shouldExecute = true;
  /** Actions */
  actions = [];
  /** Whether already executed */
  executed = false;
  /**
   * Conditional check
   */
  when(predicate) {
    if (this.shouldExecute) {
      this.shouldExecute = predicate(this.message);
    }
    return this;
  }
  /**
   * Match text pattern
   */
  matchText(pattern) {
    return this.when((m) => {
      if (!m.text) return false;
      return typeof pattern === "string" ? m.text.includes(pattern) : pattern.test(m.text);
    });
  }
  /**
   * Only process unread messages
   */
  ifUnread() {
    return this.when((m) => !m.isRead);
  }
  /**
   * Only process messages from others
   */
  ifFromOthers() {
    return this.when((m) => !m.isFromMe);
  }
  /**
   * Only process my own messages
   */
  ifFromMe() {
    return this.when((m) => m.isFromMe);
  }
  /**
   * Only process group chat messages
   */
  ifGroupChat() {
    return this.when((m) => m.isGroupChat);
  }
  /**
   * Reply with text
   *
   * Automatically routes to recipient or group based on message.chatId
   */
  replyText(text) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        const replyText = typeof text === "function" ? text(this.message) : text;
        if (isGroupChatId(this.message.chatId)) {
          await this.sender.sendToGroup({ groupId: this.message.chatId, text: replyText });
        } else {
          const extracted = extractRecipientFromChatId(this.message.chatId);
          const recipient = extracted || asRecipient(this.message.chatId);
          await this.sender.send({ to: recipient, text: replyText });
        }
      });
    }
    return this;
  }
  /**
   * Reply with image
   *
   * Automatically routes to recipient or group based on message.chatId
   */
  replyImage(images) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        const imagePaths = typeof images === "function" ? images(this.message) : images;
        const paths = Array.isArray(imagePaths) ? imagePaths : [imagePaths];
        if (isGroupChatId(this.message.chatId)) {
          await this.sender.sendToGroup({ groupId: this.message.chatId, attachments: paths });
        } else {
          const extracted = extractRecipientFromChatId(this.message.chatId);
          const recipient = extracted || asRecipient(this.message.chatId);
          await this.sender.send({ to: recipient, attachments: paths });
        }
      });
    }
    return this;
  }
  /**
   * Execute custom operation
   */
  do(handler) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        await Promise.resolve(handler(this.message));
      });
    }
    return this;
  }
  /**
   * Execute all operations (explicit call)
   *
   * This is the only method that actually performs operations
   *
   * @throws If an error occurs during execution
   */
  async execute() {
    this.executed = true;
    if (!this.shouldExecute || this.actions.length === 0) {
      return;
    }
    for (const action of this.actions) {
      await action();
    }
  }
};

// src/core/errors.ts
var IMessageError = class _IMessageError extends Error {
  constructor(code, message, options) {
    super(message, options);
    this.code = code;
    this.name = "IMessageError";
    Error.captureStackTrace?.(this, this.constructor);
  }
  /** Type guard */
  static is(error) {
    return error instanceof _IMessageError;
  }
  /** Check if error is of specific type */
  is(code) {
    return this.code === code;
  }
};
var PlatformError = (msg = "Only macOS is supported", cause) => new IMessageError("PLATFORM", msg, cause ? { cause } : void 0);
var DatabaseError = (msg, cause) => new IMessageError("DATABASE", msg, cause ? { cause } : void 0);
var SendError = (msg, cause) => new IMessageError("SEND", msg, cause ? { cause } : void 0);
var WebhookError = (msg, cause) => new IMessageError("WEBHOOK", msg, cause ? { cause } : void 0);
var ConfigError = (msg, cause) => new IMessageError("CONFIG", msg, cause ? { cause } : void 0);

// src/plugins/core.ts
var PluginManager = class {
  /** List of registered plugins */
  plugins = [];
  /** Whether the plugin manager has been initialized */
  initialized = false;
  /**
   * Register a plugin
   * If the manager is already initialized, the plugin's onInit hook will be called immediately
   * @param plugin Plugin instance
   * @returns this - Supports method chaining
   */
  use(plugin) {
    this.plugins.push(plugin);
    if (this.initialized && plugin.onInit) {
      Promise.resolve(plugin.onInit()).catch((error) => {
        const errorMsg = `[Plugin ${plugin.name}] Initialization failed:`;
        console.error(errorMsg, error);
      });
    }
    return this;
  }
  /**
   * Initialize all plugins
   * Calls the onInit hook for all plugins
   */
  async init() {
    this.initialized = true;
    await this.callHookForAll("onInit");
  }
  /**
   * Destroy all plugins
   * Calls the onDestroy hook for all plugins and clears the plugin list
   */
  async destroy() {
    await this.callHookForAll("onDestroy");
    this.plugins = [];
    this.initialized = false;
  }
  /**
   * Call the specified hook for all plugins
   * @param hookName Hook name
   * @param args Hook arguments
   * @returns List of plugin errors (if any)
   */
  async callHookForAll(hookName, ...args) {
    const pluginsWithHook = this.plugins.filter((p) => p[hookName]);
    if (pluginsWithHook.length === 0) {
      return [];
    }
    const results = await Promise.allSettled(
      pluginsWithHook.map(async (plugin) => {
        try {
          const hook = plugin[hookName];
          const hookFn = hook;
          await Promise.resolve(hookFn(...args));
          return {
            plugin: plugin.name,
            success: true
          };
        } catch (error) {
          const normalizedError = error instanceof Error ? error : new Error(String(error));
          return {
            plugin: plugin.name,
            success: false,
            error: normalizedError
          };
        }
      })
    );
    const errors = [];
    for (const result of results) {
      if (result.status === "fulfilled" && !result.value.success) {
        errors.push({
          plugin: result.value.plugin,
          error: result.value.error
        });
      } else if (result.status === "rejected") {
        const normalizedError = result.reason instanceof Error ? result.reason : new Error(String(result.reason));
        errors.push({
          plugin: "unknown",
          error: normalizedError
        });
      }
    }
    if (errors.length > 0 && hookName !== "onError") {
      for (const { plugin, error } of errors) {
        console.error(`[Plugin ${plugin}] ${hookName} failed:`, error);
        try {
          const context = `Plugin ${plugin} - ${String(hookName)}`;
          await this.callHookForAll("onError", error, context);
        } catch {
        }
      }
    }
    return errors;
  }
};
var definePlugin = (plugin) => plugin;

// src/utils/platform.ts
var requireMacOS = () => {
  if (process.platform !== "darwin") {
    throw PlatformError("Only macOS is supported");
  }
};
var isMacOS = () => {
  return process.platform === "darwin";
};
var getDefaultDatabasePath = () => {
  const home = process.env.HOME;
  if (!home) {
    throw new Error("HOME environment variable is not set");
  }
  return `${home}/Library/Messages/chat.db`;
};
var TEMP_FILE_PREFIX = "imsg_temp_";
var TEMP_DIR = join(homedir(), "Pictures");
var DEFAULT_CONFIG = {
  /** File retention time (milliseconds), default 10 minutes */
  maxAge: 10 * 60 * 1e3,
  /** Cleanup interval (milliseconds), default 5 minutes */
  cleanupInterval: 5 * 60 * 1e3
};
var TempFileManager = class {
  config;
  cleanupTimer = null;
  isDestroyed = false;
  constructor(config = {}) {
    this.config = {
      maxAge: config.maxAge ?? DEFAULT_CONFIG.maxAge,
      cleanupInterval: config.cleanupInterval ?? DEFAULT_CONFIG.cleanupInterval,
      debug: config.debug ?? false
    };
  }
  /**
   * Start cleanup task
   */
  start() {
    if (this.isDestroyed) {
      throw new Error("TempFileManager is destroyed, cannot start");
    }
    this.cleanup().catch((error) => {
      if (this.config.debug) {
        console.error("[TempFileManager] Startup cleanup failed:", error);
      }
    });
    this.cleanupTimer = setInterval(() => {
      this.cleanup().catch((error) => {
        if (this.config.debug) {
          console.error("[TempFileManager] Periodic cleanup failed:", error);
        }
      });
    }, this.config.cleanupInterval);
    this.cleanupTimer.unref();
    if (this.config.debug) {
      const intervalSec = this.config.cleanupInterval / 1e3;
      const maxAgeSec = this.config.maxAge / 1e3;
      console.log(
        `[TempFileManager] Started, cleanup interval: ${intervalSec}s, max file retention: ${maxAgeSec}s`
      );
    }
  }
  /**
   * Clean up old temporary files
   *
   * By scanning ~/Pictures directory,
   * auto-discover and clean all imsg_temp_* files exceeding retention time
   */
  async cleanup() {
    if (this.isDestroyed) {
      return { removed: 0, errors: 0 };
    }
    let removed = 0;
    let errors = 0;
    const now = Date.now();
    try {
      if (existsSync(TEMP_DIR)) {
        const files = readdirSync(TEMP_DIR);
        for (const file of files) {
          if (!file.startsWith(TEMP_FILE_PREFIX)) {
            continue;
          }
          const filePath = join(TEMP_DIR, file);
          try {
            const stats = statSync(filePath);
            const fileAge = now - stats.mtimeMs;
            if (fileAge > this.config.maxAge) {
              unlinkSync(filePath);
              removed++;
              if (this.config.debug) {
                const ageMinutes = (fileAge / 6e4).toFixed(1);
                console.log(`[TempFileManager] Removed old file: ${file} (${ageMinutes} minutes ago)`);
              }
            }
          } catch (error) {
            errors++;
            if (this.config.debug) {
              console.error(`[TempFileManager] Failed to remove file: ${file}`, error);
            }
          }
        }
      }
      if (this.config.debug && (removed > 0 || errors > 0)) {
        console.log(`[TempFileManager] Cleanup complete: removed ${removed} files, ${errors} errors`);
      }
    } catch (error) {
      if (this.config.debug) {
        console.error("[TempFileManager] Cleanup process error:", error);
      }
    }
    return { removed, errors };
  }
  /**
   * Clean up all temporary files (regardless of time)
   *
   * Called when SDK is destroyed, immediately clean all imsg_temp_* files
   */
  async cleanupAll() {
    if (this.isDestroyed) {
      return { removed: 0, errors: 0 };
    }
    let removed = 0;
    let errors = 0;
    try {
      if (existsSync(TEMP_DIR)) {
        const files = readdirSync(TEMP_DIR);
        for (const file of files) {
          if (!file.startsWith(TEMP_FILE_PREFIX)) {
            continue;
          }
          const filePath = join(TEMP_DIR, file);
          try {
            unlinkSync(filePath);
            removed++;
            if (this.config.debug) {
              console.log(`[TempFileManager] Removed file: ${file}`);
            }
          } catch (error) {
            errors++;
            if (this.config.debug) {
              console.error(`[TempFileManager] Failed to remove file: ${file}`, error);
            }
          }
        }
      }
      if (this.config.debug) {
        console.log(`[TempFileManager] Cleanup all files complete: removed ${removed}, ${errors} errors`);
      }
    } catch (error) {
      if (this.config.debug) {
        console.error("[TempFileManager] Cleanup all files error:", error);
      }
    }
    return { removed, errors };
  }
  /**
   * Stop cleanup task
   */
  stop() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
  }
  /**
   * Destroy manager (stop cleanup and clean all files)
   */
  async destroy() {
    if (this.isDestroyed) {
      return;
    }
    this.isDestroyed = true;
    this.stop();
    await this.cleanupAll();
    if (this.config.debug) {
      console.log("[TempFileManager] Destroyed");
    }
  }
  /**
   * Get statistics
   */
  getStats() {
    let currentFiles = 0;
    try {
      if (existsSync(TEMP_DIR)) {
        const files = readdirSync(TEMP_DIR);
        currentFiles = files.filter((f) => f.startsWith(TEMP_FILE_PREFIX)).length;
      }
    } catch {
    }
    return {
      currentFiles,
      isRunning: this.cleanupTimer !== null,
      config: { ...this.config }
    };
  }
};

// src/core/constants.ts
var ERROR_SDK_DESTROYED = "SDK is destroyed";
var ERROR_WATCHER_RUNNING = "Watcher is already running";
var execAsync = promisify(exec);
var str = (v, fallback = "") => v == null ? fallback : String(v);
var num = (v, fallback = 0) => typeof v === "number" ? v : fallback;
var bool = (v) => Boolean(v);
var Database;
async function initDatabase() {
  if (Database) return;
  if (typeof Bun !== "undefined") {
    const bunSqlite = await import('bun:sqlite');
    Database = bunSqlite.Database;
  } else {
    try {
      const BetterSqlite3 = await import('better-sqlite3');
      Database = BetterSqlite3.default || BetterSqlite3;
    } catch (_error) {
      throw DatabaseError(
        "better-sqlite3 is required for Node.js runtime. Install it with: npm install better-sqlite3"
      );
    }
  }
}
var IMessageDatabase = class {
  /** SQLite database instance */
  db;
  /** macOS epoch time (timestamp of 2001-01-01) */
  MAC_EPOCH = (/* @__PURE__ */ new Date("2001-01-01T00:00:00Z")).getTime();
  /** Initialization promise */
  initPromise;
  /**
   * Open iMessage database
   * @param path Database file path
   * @throws DatabaseError When database fails to open
   */
  constructor(path2) {
    this.initPromise = this.init(path2);
  }
  /**
   * Initialize database (async)
   */
  async init(path2) {
    try {
      await initDatabase();
      this.db = new Database(path2, { readonly: true });
    } catch (error) {
      throw DatabaseError(
        `Failed to open database at ${path2}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Ensure database is initialized before any operation
   */
  async ensureInit() {
    await this.initPromise;
  }
  /**
   * Query messages (with multiple filter options)
   *
   * @param filter Filter conditions (optional)
   * @returns Message query result (includes message list and statistics)
   * @throws DatabaseError When query fails
   *
   * @example Query all unread messages
   * ```ts
   * const result = await db.getMessages({ unreadOnly: true })
   * ```
   *
   * @example Query messages from specific sender
   * ```ts
   * const result = await db.getMessages({
   *   sender: '+1234567890',
   *   limit: 20
   * })
   * ```
   *
   * @example Query recent messages with attachments
   * ```ts
   * const result = await db.getMessages({
   *   hasAttachments: true,
   *   since: new Date('2024-01-01'),
   *   limit: 10
   * })
   * ```
   */
  async getMessages(filter = {}) {
    await this.ensureInit();
    const {
      unreadOnly,
      excludeOwnMessages = true,
      sender,
      chatId,
      service,
      hasAttachments,
      since,
      search,
      limit
    } = filter;
    let query = `
        SELECT 
            message.ROWID as id,
            message.guid,
            message.text,
            message.attributedBody,
            message.date,
            message.is_read,
            message.is_from_me,
            message.service,
            handle.id as sender,
            handle.ROWID as sender_rowid,
            chat.chat_identifier as chat_id,
            chat.display_name as chat_name,
            chat.ROWID as chat_rowid,
            (SELECT COUNT(*) FROM chat_handle_join WHERE chat_handle_join.chat_id = chat.ROWID) > 1 as is_group_chat
        FROM message
        LEFT JOIN handle ON message.handle_id = handle.ROWID
        LEFT JOIN chat_message_join ON message.ROWID = chat_message_join.message_id
        LEFT JOIN chat ON chat_message_join.chat_id = chat.ROWID
        WHERE 1=1
        `;
    const params = [];
    if (unreadOnly) {
      query += " AND message.is_read = 0";
    }
    if (excludeOwnMessages) {
      query += " AND message.is_from_me = 0";
    }
    if (sender) {
      query += " AND handle.id = ?";
      params.push(sender);
    }
    if (chatId) {
      query += " AND chat.chat_identifier = ?";
      params.push(chatId);
    }
    if (service) {
      query += " AND message.service = ?";
      params.push(service);
    }
    if (hasAttachments) {
      query += `
            AND EXISTS (
                SELECT 1 FROM message_attachment_join 
                WHERE message_attachment_join.message_id = message.ROWID
            )
            `;
    }
    if (since) {
      const macTimestampNs = (since.getTime() - this.MAC_EPOCH) * 1e6;
      query += " AND message.date >= ?";
      params.push(macTimestampNs);
    }
    if (search) {
      query += " AND (message.text LIKE ? OR message.attributedBody LIKE ?)";
      params.push(`%${search}%`, `%${search}%`);
    }
    query += " ORDER BY message.date DESC";
    if (limit) {
      query += " LIMIT ?";
      params.push(limit);
    }
    try {
      const rows = this.db.prepare(query).all(...params);
      const messages = await Promise.all(rows.map((row) => this.rowToMessage(row)));
      return {
        messages,
        total: messages.length,
        unreadCount: messages.filter((m) => !m.isRead).length
      };
    } catch (error) {
      throw DatabaseError(`Failed to query messages: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get unread messages grouped by sender
   *
   * @returns Object with grouped messages and total count
   *
   * @example
   * ```ts
   * const { grouped, total } = await db.getUnreadMessages()
   * for (const [sender, messages] of grouped) {
   *   console.log(`${sender}: ${messages.length} unread messages`)
   * }
   * console.log(`Total: ${total}`)
   * ```
   */
  async getUnreadMessages() {
    const { messages, total } = await this.getMessages({ unreadOnly: true });
    const grouped = /* @__PURE__ */ new Map();
    for (const msg of messages) {
      const existing = grouped.get(msg.sender);
      if (existing) {
        existing.push(msg);
      } else {
        grouped.set(msg.sender, [msg]);
      }
    }
    return { grouped, total };
  }
  /**
   * List chats with filtering and sorting options
   *
   * @param options Filter and sort options
   * @returns Array of chat summaries with unread counts
   *
   * @example
   * ```ts
   * // Get recent group chats with unread messages
   * const chats = await db.listChats({
   *   type: 'group',
   *   hasUnread: true,
   *   limit: 20
   * })
   * ```
   */
  async listChats(options = {}) {
    await this.ensureInit();
    const { limit, type = "all", hasUnread, sortBy = "recent", search } = options;
    let query = `
        SELECT 
            chat.chat_identifier AS chat_identifier,
            chat.guid AS chat_guid,
            chat.service_name AS service_name,
            chat.display_name AS display_name,
            (
              SELECT MAX(message.date) 
              FROM chat_message_join cmj 
              INNER JOIN message ON message.ROWID = cmj.message_id 
              WHERE cmj.chat_id = chat.ROWID
            ) AS last_date,
            (SELECT COUNT(*) FROM chat_handle_join WHERE chat_handle_join.chat_id = chat.ROWID) > 1 AS is_group_chat,
            (
              SELECT COUNT(*) 
              FROM chat_message_join cmj 
              INNER JOIN message ON message.ROWID = cmj.message_id 
              WHERE cmj.chat_id = chat.ROWID 
                AND message.is_read = 0 
                AND message.is_from_me = 0
            ) AS unread_count
        FROM chat
        WHERE 1=1
        `;
    const params = [];
    if (type === "group") {
      query += " AND (SELECT COUNT(*) FROM chat_handle_join WHERE chat_handle_join.chat_id = chat.ROWID) > 1";
    } else if (type === "dm") {
      query += " AND (SELECT COUNT(*) FROM chat_handle_join WHERE chat_handle_join.chat_id = chat.ROWID) <= 1";
    }
    if (hasUnread) {
      query += " AND (SELECT COUNT(*) FROM chat_message_join cmj INNER JOIN message ON message.ROWID = cmj.message_id WHERE cmj.chat_id = chat.ROWID AND message.is_read = 0 AND message.is_from_me = 0) > 0";
    }
    if (search) {
      query += " AND chat.display_name LIKE ?";
      params.push(`%${search}%`);
    }
    if (sortBy === "recent") {
      query += " ORDER BY (last_date IS NULL), last_date DESC";
    } else if (sortBy === "name") {
      query += " ORDER BY (chat.display_name IS NULL), chat.display_name ASC";
    }
    if (limit && limit > 0) {
      query += " LIMIT ?";
      params.push(limit);
    }
    try {
      const rows = this.db.prepare(query).all(...params);
      return rows.map((row) => {
        const isGroup = bool(row.is_group_chat);
        const guid = str(row.chat_guid);
        const identifierRaw = row.chat_identifier == null ? "" : str(row.chat_identifier);
        const service = row.service_name == null ? "" : str(row.service_name);
        let chatId;
        if (isGroup || !identifierRaw) {
          chatId = guid;
        } else if (identifierRaw.includes(";")) {
          chatId = identifierRaw;
        } else if (service) {
          chatId = `${service};${identifierRaw}`;
        } else {
          chatId = `iMessage;${identifierRaw}`;
        }
        const displayName = row.display_name == null ? null : str(row.display_name);
        const lastDateRaw = row.last_date;
        const lastMessageAt = typeof lastDateRaw === "number" ? this.convertMacTimestamp(lastDateRaw) : null;
        const unreadCount = typeof row.unread_count === "number" ? row.unread_count : 0;
        return {
          chatId,
          displayName,
          lastMessageAt,
          isGroup,
          unreadCount
        };
      });
    } catch (error) {
      throw DatabaseError(`Failed to list chats: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get all attachments for specified message
   * @param messageId Message ID
   * @returns Array of attachments, returns empty array if no attachments
   */
  async getAttachments(messageId) {
    await this.ensureInit();
    const query = `
        SELECT 
            attachment.ROWID as id,
            attachment.filename,
            attachment.mime_type,
            attachment.total_bytes as size,
            attachment.created_date as created_date
        FROM attachment
        INNER JOIN message_attachment_join ON attachment.ROWID = message_attachment_join.attachment_id
        WHERE message_attachment_join.message_id = ?
        `;
    try {
      const rows = this.db.prepare(query).all(messageId);
      return rows.map((row) => {
        const rawPath = str(row.filename);
        const mimeType = str(row.mime_type, "application/octet-stream");
        let fullPath;
        if (rawPath.startsWith("~")) {
          fullPath = rawPath.replace(/^~/, homedir());
        } else if (rawPath && !rawPath.startsWith("/")) {
          fullPath = join(homedir(), "Library/Messages/Attachments", rawPath);
        } else {
          fullPath = rawPath;
        }
        return {
          id: str(row.id),
          filename: rawPath.split("/").pop() || "unknown",
          mimeType,
          path: fullPath,
          size: num(row.size, 0),
          isImage: mimeType.startsWith("image/"),
          createdAt: this.convertMacTimestamp(row.created_date)
        };
      });
    } catch {
      return [];
    }
  }
  /**
   * Decode XML entities in a string
   * @param text Text with XML entities
   * @returns Decoded text
   */
  decodeXmlEntities(text) {
    return text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'");
  }
  /**
   * Extract text from attributedBody (binary plist format)
   * @param attributedBody Binary plist data
   * @returns Extracted text or null if extraction fails
   */
  async extractTextFromAttributedBody(attributedBody) {
    if (!attributedBody) return null;
    try {
      let buffer;
      if (Buffer.isBuffer(attributedBody)) {
        buffer = attributedBody;
      } else if (attributedBody instanceof Uint8Array) {
        buffer = Buffer.from(attributedBody);
      } else {
        return null;
      }
      const bufferStr = buffer.toString("utf8");
      const excludedPatterns = /^(NSAttributedString|NSMutableAttributedString|NSObject|NSString|NSMutableString|NSDictionary|NSNumber|NSValue|streamtyped|__kIMMessagePartAttributeName|__kIMPhoneNumberAttributeName|PhoneNumber|NS\.rangeval|locationZNS\.special)$/i;
      const readableMatches = bufferStr.match(/[\x20-\x7E\u4e00-\u9fff]{5,}/g);
      if (readableMatches) {
        const messageCandidates = readableMatches.filter((match) => {
          if (excludedPatterns.test(match)) return false;
          if (/^[\[\(\)\]\*,\-:X]+$/.test(match)) return false;
          if (/^NS\.\w+/.test(match)) return false;
          if (/^__kIM/.test(match)) return false;
          if (/\$version|\$archiver|\$top|\$objects|\$class/.test(match)) return false;
          return match.length > 5;
        }).map((match) => ({
          text: match,
          // Score: higher for Chinese characters, longer text, and content-like patterns
          score: (match.match(/[\u4e00-\u9fff]/g)?.length || 0) * 10 + match.length + (match.match(/[a-zA-Z]/) ? 5 : 0) - (match.match(/[\[\(\)\]\*,\-:X]/g)?.length || 0) * 5 - (match.match(/^__kIM|^NS\.|\$version|\$archiver|\$top|\$objects|\$class/) ? 100 : 0)
          // Heavily penalize attribute names and plist markers
        })).sort((a, b) => b.score - a.score);
        if (messageCandidates.length > 0) {
          const bestCandidate = messageCandidates[0];
          return bestCandidate.text.replace(/^\+"/, "").replace(/"$/, "").trim();
        }
      }
      const tempFile = join(
        tmpdir(),
        `imsg_attributedBody_${Date.now()}_${Math.random().toString(36).substring(7)}.plist`
      );
      try {
        await writeFile(tempFile, buffer);
        const { stdout } = await execAsync(`plutil -convert xml1 -o - "${tempFile}"`, {
          timeout: 5e3,
          maxBuffer: 1024 * 1024
          // 1MB buffer
        });
        const stringMatches = stdout.match(/<string>([\s\S]*?)<\/string>/g);
        if (stringMatches && stringMatches.length > 0) {
          const textCandidates = stringMatches.map((match) => {
            const textMatch = match.match(/<string>([\s\S]*?)<\/string>/);
            return textMatch?.[1];
          }).filter((text) => {
            if (!text) return false;
            const decoded = this.decodeXmlEntities(text);
            return decoded.length > 5 && !excludedPatterns.test(decoded);
          }).sort((a, b) => b.length - a.length);
          if (textCandidates.length > 0) {
            return this.decodeXmlEntities(textCandidates[0]);
          }
        }
      } finally {
        try {
          await unlink(tempFile);
        } catch {
        }
      }
    } catch (error) {
    }
    return null;
  }
  /**
   * Convert database query result to Message object
   * @param row Raw row data from database query
   * @returns Formatted Message object
   */
  async rowToMessage(row) {
    let messageText = row.text ? str(row.text) : null;
    if (!messageText && row.attributedBody) {
      messageText = await this.extractTextFromAttributedBody(row.attributedBody);
    }
    return {
      id: str(row.id),
      guid: str(row.guid),
      text: messageText,
      sender: str(row.sender, "Unknown"),
      senderName: null,
      chatId: str(row.chat_id),
      isGroupChat: bool(row.is_group_chat),
      service: this.mapService(row.service),
      isRead: bool(row.is_read),
      isFromMe: bool(row.is_from_me),
      attachments: await this.getAttachments(str(row.id)),
      date: this.convertMacTimestamp(row.date)
    };
  }
  /**
   * Map service type string from database
   * @param service Service identifier from database
   * @returns Standardized service type
   */
  mapService(service) {
    if (!service || typeof service !== "string") return "iMessage";
    const lower = service.toLowerCase();
    if (lower.includes("sms")) return "SMS";
    if (lower.includes("rcs")) return "RCS";
    return "iMessage";
  }
  /**
   * Convert macOS timestamp to JavaScript Date object
   *
   * macOS epoch starts at 2001-01-01, unit is nanoseconds
   * @param timestamp macOS timestamp
   * @returns JavaScript Date object
   */
  convertMacTimestamp(timestamp) {
    if (!timestamp || typeof timestamp !== "number") return /* @__PURE__ */ new Date();
    return new Date(this.MAC_EPOCH + timestamp / 1e6);
  }
  /**
   * Close database connection
   */
  async close() {
    await this.ensureInit();
    this.db.close();
  }
};

// src/core/outgoing-manager.ts
var OutgoingMessageManager = class {
  promises = [];
  debug;
  constructor(debug = false) {
    this.debug = debug;
  }
  /**
   * Add a new message promise to track
   */
  add(promise) {
    this.promises.push(promise);
    if (this.debug) {
      console.log(
        `[OutgoingManager] Tracking new ${promise.isAttachment ? "attachment" : "message"}: ${promise.chatId}`
      );
    }
  }
  /**
   * Try to match and resolve a message promise
   * Returns true if a match was found
   */
  tryResolve(message) {
    if (!message.isFromMe) {
      return false;
    }
    for (let i = 0; i < this.promises.length; i++) {
      const promise = this.promises[i];
      if (!promise || promise.isResolved) continue;
      if (promise.matches(message)) {
        if (this.debug) {
          console.log(`[OutgoingManager] Matched message: ${message.id}`);
        }
        promise.resolve(message);
        return true;
      }
    }
    return false;
  }
  /**
   * Clean up resolved promises (older than 1 minute)
   */
  cleanup() {
    const now = Date.now();
    const oneMinute = 60 * 1e3;
    this.promises = this.promises.filter((p) => {
      if (!p.isResolved) return true;
      return now - p.sentAt < oneMinute;
    });
  }
  /**
   * Get count of pending promises
   */
  getPendingCount() {
    return this.promises.filter((p) => !p.isResolved).length;
  }
  /**
   * Reject all pending promises (used when closing SDK)
   */
  rejectAll(reason = "SDK closed") {
    for (const promise of this.promises) {
      if (!promise.isResolved) {
        promise.reject(reason);
      }
    }
    this.promises = [];
  }
};
var execAsync2 = promisify(exec);
var DEFAULT_SCRIPT_TIMEOUT = 3e4;
var execAppleScript = async (script, debug = false, timeoutMs = DEFAULT_SCRIPT_TIMEOUT) => {
  if (debug) {
    console.log("[AppleScript] Executing script:\n", script);
  }
  try {
    const escapedScript = script.replace(/'/g, "'\\''");
    const { stdout, stderr } = await execAsync2(`osascript -e '${escapedScript}'`, {
      timeout: timeoutMs,
      encoding: "utf-8"
    });
    if (stderr && debug) {
      console.warn("[AppleScript] Warning:", stderr);
    }
    if (debug) {
      console.log("[AppleScript] Success:", stdout || "(no output)");
    }
    return stdout.trim();
  } catch (error) {
    const errorMsg = error.message || String(error);
    if (error.killed || errorMsg.includes("timeout")) {
      const message = [
        `AppleScript execution timeout (${timeoutMs}ms)`,
        "may be slow network or large file"
      ].join(" - ");
      throw new Error(message);
    }
    if (errorMsg.includes("Can't get buddy")) {
      throw new Error("Recipient not found or not added to iMessage contacts");
    }
    if (errorMsg.includes("Can't send")) {
      const reasons = [
        "1) Is Messages signed in to iMessage",
        "2) Is recipient correct",
        "3) Network connection"
      ].join(", ");
      throw new Error(`Send failed - please check: ${reasons}`);
    }
    if (debug) {
      console.error("[AppleScript] Error details:", error);
    }
    throw new Error(`AppleScript execution failed: ${errorMsg}`);
  }
};
var checkMessagesApp = async () => {
  try {
    await execAsync2("pgrep -x Messages", {
      timeout: DEFAULT_SCRIPT_TIMEOUT
    });
    return true;
  } catch {
    return false;
  }
};
var checkIMessageStatus = async (debug = false) => {
  try {
    const script = `
tell application "Messages"
    try
        set accountList to every account
        if (count of accountList) is 0 then
            return "no_accounts"
        end if
        
        set hasActiveAccount to false
        repeat with acct in accountList
            if enabled of acct is true then
                set hasActiveAccount to true
                exit repeat
            end if
        end repeat
        
        if hasActiveAccount then
            return "active"
        else
            return "inactive"
        end if
    on error
        return "error"
    end try
end tell
`;
    const escapedScript = script.replace(/'/g, "'\\''");
    const { stdout } = await execAsync2(`osascript -e '${escapedScript}'`, {
      timeout: 5e3
    });
    const result = stdout.trim();
    if (debug) {
      console.log("[iMessage Status Check]", result);
    }
    return result === "active";
  } catch (error) {
    if (debug) {
      console.warn("[iMessage Status Check Failed]", error);
    }
    return true;
  }
};
var escapeAppleScriptString = (str2) => {
  const escapeMap = {
    "\\": "\\\\",
    // Backslash
    '"': '\\"',
    // Double quote
    "\n": "\\n",
    // Newline
    "\r": "\\r",
    // Carriage return
    "	": "\\t"
    // Tab
  };
  return str2.replace(/[\\\n\r\t"]/g, (char) => escapeMap[char] || char);
};
var generateSendTextScript = (recipient, text) => {
  const escapedText = escapeAppleScriptString(text);
  return `
tell application "Messages"
    set targetBuddy to buddy "${recipient}"
    send "${escapedText}" to targetBuddy
end tell
`.trim();
};
var generateSendTextToChat = (chatId, text) => {
  const escapedText = escapeAppleScriptString(text);
  const escapedChatId = escapeAppleScriptString(chatId);
  return `
tell application "Messages"
    set targetChat to chat id "${escapedChatId}"
    send "${escapedText}" to targetChat
end tell
`.trim();
};
function needsSandboxBypass(filePath) {
  return !filePath.match(/(Pictures|Downloads|Documents)/);
}
function calculateFileDelay(filePath) {
  try {
    const fs2 = __require("fs");
    const stats = fs2.statSync(filePath);
    const sizeInMB = stats.size / (1024 * 1024);
    if (sizeInMB < 1) return 2;
    if (sizeInMB < 10) return 3;
    return 5;
  } catch {
    return 3;
  }
}
function generateSandboxBypassScript(filePath, recipient) {
  const fileName = filePath.split("/").pop();
  const tempFileName = `imsg_temp_${Date.now()}_${fileName}`;
  const delay2 = calculateFileDelay(filePath);
  return `
    -- Bypass sandbox: copy to Pictures directory
    set picturesFolder to POSIX path of (path to pictures folder)
    set targetPath to picturesFolder & "${tempFileName}"
    do shell script "cp " & quoted form of "${filePath}" & " " & quoted form of targetPath
    
    -- Create file reference and send
    set theFile to (POSIX file targetPath) as alias
    set targetBuddy to buddy "${recipient}"
    send theFile to targetBuddy
    delay ${delay2}
    `.trim();
}
function generateSandboxBypassScriptForChat(filePath, chatId) {
  const escapedChatId = escapeAppleScriptString(chatId);
  const fileName = filePath.split("/").pop();
  const tempFileName = `imsg_temp_${Date.now()}_${fileName}`;
  const delay2 = calculateFileDelay(filePath);
  return `
    -- Bypass sandbox: copy to Pictures directory
    set picturesFolder to POSIX path of (path to pictures folder)
    set targetPath to picturesFolder & "${tempFileName}"
    do shell script "cp " & quoted form of "${filePath}" & " " & quoted form of targetPath
    
    -- Create file reference and send
    set theFile to (POSIX file targetPath) as alias
    set targetChat to chat id "${escapedChatId}"
    send theFile to targetChat
    delay ${delay2}
    `.trim();
}
function generateDirectSendScript(filePath, recipient) {
  const escapedPath = escapeAppleScriptString(filePath);
  const delay2 = calculateFileDelay(filePath);
  return `
    set targetBuddy to buddy "${recipient}"
    send POSIX file "${escapedPath}" to targetBuddy
    delay ${delay2}
    `.trim();
}
function generateDirectSendScriptForChat(filePath, chatId) {
  const escapedChatId = escapeAppleScriptString(chatId);
  const escapedPath = escapeAppleScriptString(filePath);
  const delay2 = calculateFileDelay(filePath);
  return `
    set targetChat to chat id "${escapedChatId}"
    send POSIX file "${escapedPath}" to targetChat
    delay ${delay2}
    `.trim();
}
var generateSendAttachmentScript = (recipient, filePath, debug = false) => {
  const needsBypass = needsSandboxBypass(filePath);
  if (needsBypass && debug) {
    console.log("[AppleScript] Non-sandbox directory detected, will temporarily copy to ~/Pictures");
  }
  const sendScript = needsBypass ? generateSandboxBypassScript(filePath, recipient) : generateDirectSendScript(filePath, recipient);
  return {
    script: `
tell application "Messages"
${sendScript}
end tell
        `.trim()
  };
};
var generateSendAttachmentToChat = (chatId, filePath, debug = false) => {
  const needsBypass = needsSandboxBypass(filePath);
  if (needsBypass && debug) {
    console.log("[AppleScript] Non-sandbox directory detected, will temporarily copy to ~/Pictures");
  }
  const sendScript = needsBypass ? generateSandboxBypassScriptForChat(filePath, chatId) : generateDirectSendScriptForChat(filePath, chatId);
  return {
    script: `
tell application "Messages"
${sendScript}
end tell
        `.trim()
  };
};
var generateSendWithAttachmentScript = (recipient, text, filePath) => {
  const escapedText = escapeAppleScriptString(text);
  const needsBypass = needsSandboxBypass(filePath);
  const attachmentScript = needsBypass ? generateSandboxBypassScript(filePath, recipient) : generateDirectSendScript(filePath, recipient);
  return {
    script: `
tell application "Messages"
    set targetBuddy to buddy "${recipient}"
    
    -- Send text
    send "${escapedText}" to targetBuddy
    
    -- Send attachment
${attachmentScript}
end tell
        `.trim()
  };
};
var generateSendWithAttachmentToChat = (chatId, text, filePath) => {
  const escapedText = escapeAppleScriptString(text);
  const escapedChatId = escapeAppleScriptString(chatId);
  const needsBypass = needsSandboxBypass(filePath);
  const attachmentScript = needsBypass ? generateSandboxBypassScriptForChat(filePath, chatId) : generateDirectSendScriptForChat(filePath, chatId);
  return {
    script: `
tell application "Messages"
    set targetChat to chat id "${escapedChatId}"
    
    -- Send text
    send "${escapedText}" to targetChat
    
    -- Send attachment
${attachmentScript}
end tell
        `.trim()
  };
};
var execAsync3 = promisify(exec);
var TEMP_DIR2 = join(homedir(), "Pictures");
var convertImageToJPEG = async (inputPath, outputPath) => {
  const output = outputPath || join(TEMP_DIR2, `imsg_temp_${Date.now()}.jpg`);
  try {
    const cmd = `sips -s format jpeg "${inputPath}" --out "${output}"`;
    await execAsync3(cmd, { timeout: 1e4 });
    if (!existsSync(output)) {
      throw new Error("Converted file does not exist");
    }
    return output;
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    throw SendError(`Image format conversion failed: ${msg}`);
  }
};
var downloadImage = async (url, options = {}) => {
  const { timeout = 15e3, maxRetries = 2, retryDelay = 1e3, debug = false } = options;
  let lastError = null;
  if (debug) {
    console.log(`[Download] ${url.length > 60 ? `${url.slice(0, 60)}...` : url}`);
  }
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        await delay(retryDelay * 2 ** (attempt - 1));
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
          Accept: "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Accept-Encoding": "gzip, deflate, br"
        }
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText}`);
      }
      const contentType = response.headers.get("content-type")?.toLowerCase() || "";
      const buffer = Buffer.from(await response.arrayBuffer());
      if (contentType.includes("avif") || contentType.includes("webp")) {
        const ext2 = contentType.includes("avif") ? ".avif" : ".webp";
        const tempPath = join(TEMP_DIR2, `imsg_temp_${Date.now()}${ext2}`);
        writeFileSync(tempPath, buffer);
        const converted = await convertImageToJPEG(tempPath);
        if (debug) {
          console.log(`[Download] Converted ${ext2} -> .jpg`);
        }
        return converted;
      }
      const extMap = {
        png: ".png",
        gif: ".gif",
        svg: ".svg",
        bmp: ".bmp"
      };
      const ext = Object.entries(extMap).find(([key]) => contentType.includes(key))?.[1] || ".jpg";
      const path2 = join(TEMP_DIR2, `imsg_temp_${Date.now()}${ext}`);
      writeFileSync(path2, buffer);
      return path2;
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (lastError.name === "AbortError") {
        lastError = new Error(`Request timeout (${timeout}ms)`);
      }
      if (attempt === maxRetries) {
        throw SendError(`Download failed (${maxRetries + 1} attempts): ${lastError.message}
URL: ${url}`);
      }
      if (debug && attempt > 0) {
        console.warn(`[Download] Retry ${attempt + 1}/${maxRetries + 1}: ${lastError.message}`);
      }
    }
  }
  throw SendError(`Download failed: ${lastError?.message}`);
};
var convertToCompatibleFormat = async (filePath) => {
  const ext = filePath.split(".").pop()?.toLowerCase();
  if (!ext || !["avif", "webp"].includes(ext)) {
    return { path: filePath, converted: false };
  }
  const fileName = filePath.split("/").pop().replace(/\.(avif|webp)$/i, ".jpg");
  const isOurTemp = fileName.startsWith("imsg_temp_");
  const output = isOurTemp ? join(TEMP_DIR2, fileName) : join(TEMP_DIR2, `imsg_temp_${Date.now()}_${fileName}`);
  const converted = await convertImageToJPEG(filePath, output);
  return { path: converted, converted: true };
};

// src/utils/semaphore.ts
var Semaphore = class {
  constructor(limit) {
    this.limit = limit;
    if (limit <= 0) {
      throw new Error("Concurrency limit must be greater than 0");
    }
  }
  running = 0;
  waiting = [];
  /**
   * Acquire semaphore
   *
   * @returns Release function
   */
  async acquire() {
    while (this.running >= this.limit) {
      await new Promise((resolve2) => this.waiting.push(resolve2));
    }
    this.running++;
    return () => {
      this.running--;
      const next = this.waiting.shift();
      if (next) {
        next();
      }
    };
  }
  /**
   * Run async function (auto-manage semaphore)
   *
   * @param fn Async function
   * @returns Function execution result
   */
  async run(fn) {
    const release = await this.acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  }
};

// src/core/message-promise.ts
var MessagePromiseRejection = class extends Error {
  error;
  msg;
  tempGuid;
  constructor(error, message, tempGuid) {
    super(error);
    this.name = this.constructor.name;
    this.error = error;
    this.msg = message ?? null;
    this.tempGuid = tempGuid ?? null;
    Error.captureStackTrace(this, this.constructor);
  }
};
var MessagePromise = class {
  promise;
  resolvePromise;
  rejectPromise;
  chatId;
  text;
  attachmentName;
  isAttachment;
  sentAt;
  debug;
  isResolved = false;
  errored = false;
  error = null;
  timeoutHandle;
  constructor(options) {
    this.debug = options.debug ?? false;
    this.chatId = options.chatId;
    this.text = this.normalizeText(options.text ?? "");
    this.attachmentName = options.attachmentName ?? null;
    this.isAttachment = options.isAttachment;
    this.sentAt = typeof options.sentAt === "number" ? options.sentAt : options.sentAt.getTime();
    this.promise = new Promise((resolve2, reject) => {
      this.resolvePromise = resolve2;
      this.rejectPromise = reject;
    });
    this.promise.catch((err) => {
      this.errored = true;
      this.error = err;
    });
    const timeout = this.isAttachment ? 30 * 1e3 : 10 * 1e3;
    this.timeoutHandle = setTimeout(() => {
      if (!this.isResolved) {
        this.reject(`Message send timeout after ${timeout}ms`);
      }
    }, timeout);
  }
  /**
   * Normalize text for comparison
   * Only remove whitespace and convert to lowercase for case-insensitive matching
   * Keep all other characters including Unicode (Chinese, emoji, etc.)
   */
  normalizeText(text) {
    return text.replace(/\s+/g, "").toLowerCase();
  }
  /**
   * Get filename without extension
   */
  getFilenameWithoutExtension(filename) {
    const lastDot = filename.lastIndexOf(".");
    if (lastDot === -1) return filename;
    return filename.substring(0, lastDot);
  }
  /**
   * Resolve the promise with the sent message
   */
  resolve(message) {
    if (this.isResolved) return;
    this.isResolved = true;
    clearTimeout(this.timeoutHandle);
    this.resolvePromise(message);
  }
  /**
   * Reject the promise with an error
   */
  reject(reason, message) {
    if (this.isResolved) return;
    this.isResolved = true;
    clearTimeout(this.timeoutHandle);
    this.rejectPromise(new MessagePromiseRejection(reason, message));
  }
  /**
   * Check if this promise matches the given message
   */
  matches(message) {
    const timeDiff = message.date.getTime() - this.sentAt;
    if (timeDiff < -5e3) {
      if (this.debug) console.log("[MessagePromise] Time check failed:", { timeDiff, tooOld: true });
      return false;
    }
    if (!this.matchesChatId(message.chatId)) {
      if (this.debug)
        console.log("[MessagePromise] ChatId mismatch:", {
          expected: this.chatId,
          actual: message.chatId
        });
      return false;
    }
    if (this.isAttachment) {
      if (!message.attachments || message.attachments.length === 0) {
        if (this.debug) console.log("[MessagePromise] No attachments in message");
        return false;
      }
      if (this.attachmentName) {
        const normalizedName = this.getFilenameWithoutExtension(this.attachmentName).toLowerCase();
        const match = message.attachments.some((att) => {
          const attName = this.getFilenameWithoutExtension(att.filename).toLowerCase();
          return attName === normalizedName;
        });
        if (this.debug)
          console.log("[MessagePromise] Attachment match:", {
            expected: normalizedName,
            actual: message.attachments.map(
              (a) => this.getFilenameWithoutExtension(a.filename).toLowerCase()
            ),
            match
          });
        return match;
      }
      return true;
    }
    const messageText = this.normalizeText(message.text ?? "");
    const matches = this.text === messageText;
    if (this.debug) {
      console.log("[MessagePromise] Text match:", {
        expected: this.text,
        actual: messageText,
        matches,
        originalText: message.text
      });
    }
    return matches;
  }
  /**
   * Check if chat ID matches (handles different formats)
   */
  matchesChatId(chatId) {
    if (chatId === this.chatId) return true;
    const normalized1 = this.normalizeChatId(chatId);
    const normalized2 = this.normalizeChatId(this.chatId);
    return normalized1 === normalized2;
  }
  /**
   * Normalize chat ID for comparison
   *
   * Handles format differences between what we construct and what's in the database:
   *
   * Database stores (from message.chatId):
   * - DM: "pilot@photon.codes" (no prefix)
   * - Group: "chat493787071395575843" (no prefix)
   *
   * We construct (in sender.ts):
   * - DM: "iMessage;-;pilot@photon.codes"
   * - Group: "iMessage;+;chat493787071395575843" or just the GUID
   *
   * This method extracts the core identifier (last part after semicolons) to ensure
   * both formats match correctly. For example:
   * - "iMessage;-;pilot@photon.codes"  "pilot@photon.codes"
   * - "pilot@photon.codes"  "pilot@photon.codes"
   * Both normalize to the same value, enabling successful matching.
   */
  normalizeChatId(chatId) {
    if (chatId.includes(";")) {
      const parts = chatId.split(";");
      return parts[parts.length - 1] ?? chatId;
    }
    return chatId;
  }
};

// src/core/sender.ts
var MessageSender = class {
  /** Debug mode */
  debug;
  /** Maximum retry attempts */
  maxRetries;
  /** Retry delay */
  retryDelay;
  /** Concurrency limiter */
  semaphore;
  /** AppleScript timeout */
  scriptTimeout;
  /** Outgoing message manager */
  outgoingManager = null;
  constructor(debug = false, retryConfig, maxConcurrent = 5, scriptTimeout = 3e4) {
    this.debug = debug;
    this.maxRetries = retryConfig?.max ?? 2;
    this.retryDelay = retryConfig?.delay ?? 1500;
    this.semaphore = maxConcurrent > 0 ? new Semaphore(maxConcurrent) : null;
    this.scriptTimeout = scriptTimeout;
  }
  /**
   * Set outgoing message manager (called by SDK)
   */
  setOutgoingManager(manager) {
    this.outgoingManager = manager;
  }
  /**
   * Execute script with retry
   *
   * @param script AppleScript code
   * @param description Operation description
   * @returns Execution result
   */
  async executeWithRetry(script, description) {
    let lastError = null;
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        if (attempt > 1) {
          await delay(this.retryDelay);
        }
        await execAppleScript(script, this.debug, this.scriptTimeout);
        return;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    const errorMsg = lastError?.message || "unknown error";
    throw SendError(`${description} failed (retried ${this.maxRetries} times): ${errorMsg}`);
  }
  /**
   * Resolve attachment path
   * - Download network images (HTTP URL)  ~/Pictures/imsg_temp_*
   * - Validate local file path
   * - Auto-convert incompatible formats (AVIF/WebP -> JPEG)  ~/Pictures/imsg_temp_*
   *
   * Note: All temporary files are automatically named imsg_temp_* and stored in ~/Pictures
   *       TempFileManager will automatically scan and clean up these files, no manual tracking needed
   *
   * @param path Attachment path (local path or HTTP URL)
   * @returns Local path
   */
  async resolveAttachment(path2) {
    if (isURL(path2)) {
      return await downloadImage(path2, { debug: this.debug });
    }
    const localPath = resolve(path2);
    if (!existsSync(localPath)) {
      throw SendError(`File not found: ${path2}`);
    }
    const converted = await convertToCompatibleFormat(localPath);
    if (converted.converted && this.debug) {
      const originalFile = localPath.split("/").pop();
      const convertedFile = converted.path.split("/").pop();
      console.log(`[Format Conversion] ${originalFile} -> ${convertedFile}`);
    }
    return converted.path;
  }
  /**
   * Send message to recipient
   */
  async send(options) {
    const task = async () => {
      const { to, text, attachments = [], signal } = options;
      const target = String(to);
      this.checkAbortSignal(signal);
      let hasText;
      try {
        const validation = validateMessageContent(text, attachments);
        hasText = validation.hasText;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        throw SendError(errorMsg);
      }
      try {
        this.checkAbortSignal(signal);
        await this.checkMessagesEnvironment();
        const paths = await this.prepareAttachments(attachments);
        const recipient = asRecipient(target);
        const chatId = `iMessage;-;${recipient}`;
        const sentAt = /* @__PURE__ */ new Date();
        let messagePromise = null;
        if (this.outgoingManager && paths.length > 0) {
          const attachmentName = paths[0]?.split("/").pop();
          messagePromise = new MessagePromise({
            chatId,
            text,
            attachmentName,
            isAttachment: true,
            sentAt
          });
          this.outgoingManager.add(messagePromise);
        } else if (this.outgoingManager && hasText) {
          messagePromise = new MessagePromise({
            chatId,
            text,
            isAttachment: false,
            sentAt
          });
          this.outgoingManager.add(messagePromise);
        }
        await this.sendToRecipient(recipient, text, hasText, paths);
        let confirmedMessage;
        if (messagePromise) {
          try {
            confirmedMessage = await messagePromise.promise;
            if (this.debug) {
              console.log("[Sender] Message confirmed in database");
            }
          } catch (promiseError) {
            if (this.debug) {
              console.warn("[Sender] Message promise rejected:", promiseError);
            }
          }
        }
        return { sentAt, message: confirmedMessage };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        const context = `[To: ${target}] [Text: ${hasText ? "yes" : "no"}] [Attachments: ${attachments.length}]`;
        const cause = error instanceof Error ? error : void 0;
        if (error instanceof IMessageError) {
          throw SendError(`${errorMsg} ${context}`, cause);
        }
        throw SendError(`Send failed ${context}: ${errorMsg}`, cause);
      }
    };
    return this.semaphore ? await this.semaphore.run(task) : await task();
  }
  /**
   * Check abort signal
   */
  checkAbortSignal(signal) {
    if (signal?.aborted) {
      throw SendError("Send cancelled");
    }
  }
  /**
   * Check Messages environment
   */
  async checkMessagesEnvironment() {
    const isAvailable = await checkMessagesApp();
    if (!isAvailable) {
      throw SendError("Messages app is not running");
    }
    if (this.debug) {
      const iMessageActive = await checkIMessageStatus(this.debug);
      if (!iMessageActive) {
        console.warn(
          '[Warning] iMessage account may not be logged in or activated, messages may show "Not Delivered"'
        );
        console.warn("[Suggestion] Open Messages app > Settings > iMessage, ensure Apple ID is logged in");
      }
    }
  }
  /**
   * Prepare all attachments (download, convert)
   */
  async prepareAttachments(attachments) {
    if (attachments.length === 0) {
      return [];
    }
    if (this.debug) {
      console.log(`[Processing Attachments] Total ${attachments.length} attachments`);
    }
    const resolvedPaths = [];
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (this.debug) {
        const attachmentPreview = attachment.length > 80 ? `${attachment.slice(0, 80)}...` : attachment;
        console.log(`[Processing Attachments] ${i + 1}/${attachments.length}: ${attachmentPreview}`);
      }
      const resolved = await this.resolveAttachment(attachment);
      resolvedPaths.push(resolved);
    }
    return resolvedPaths;
  }
  /**
   * Send to recipient using buddy method
   */
  async sendToRecipient(recipient, text, hasText, resolvedPaths) {
    if (hasText && resolvedPaths.length > 0) {
      const firstAttachment = resolvedPaths[0];
      const { script } = generateSendWithAttachmentScript(recipient, text, firstAttachment);
      await this.executeWithRetry(script, `Send text and attachment to ${recipient}`);
      for (let i = 1; i < resolvedPaths.length; i++) {
        const { script: attachScript } = generateSendAttachmentScript(recipient, resolvedPaths[i], this.debug);
        await this.executeWithRetry(attachScript, `Send attachment ${i + 1}/${resolvedPaths.length}`);
        if (i < resolvedPaths.length - 1) {
          await delay(500);
        }
      }
    } else if (hasText) {
      const script = generateSendTextScript(recipient, text);
      await this.executeWithRetry(script, `Send text to ${recipient}`);
    } else {
      for (let i = 0; i < resolvedPaths.length; i++) {
        const { script } = generateSendAttachmentScript(recipient, resolvedPaths[i], this.debug);
        const description = `Send attachment ${i + 1}/${resolvedPaths.length} to ${recipient}`;
        await this.executeWithRetry(script, description);
        if (i < resolvedPaths.length - 1) {
          await delay(500);
        }
      }
    }
  }
  /**
   * Send to group using chat id method
   */
  async sendToGroupChat(groupId, text, hasText, resolvedPaths) {
    if (hasText && resolvedPaths.length > 0) {
      const firstAttachment = resolvedPaths[0];
      const { script } = generateSendWithAttachmentToChat(groupId, text, firstAttachment);
      await this.executeWithRetry(script, `Send text and attachment to group ${groupId}`);
      for (let i = 1; i < resolvedPaths.length; i++) {
        const { script: attachScript } = generateSendAttachmentToChat(groupId, resolvedPaths[i], this.debug);
        await this.executeWithRetry(attachScript, `Send attachment ${i + 1}/${resolvedPaths.length}`);
        if (i < resolvedPaths.length - 1) {
          await delay(500);
        }
      }
    } else if (hasText) {
      const script = generateSendTextToChat(groupId, text);
      await this.executeWithRetry(script, `Send text to group ${groupId}`);
    } else {
      for (let i = 0; i < resolvedPaths.length; i++) {
        const { script } = generateSendAttachmentToChat(groupId, resolvedPaths[i], this.debug);
        const description = `Send attachment ${i + 1}/${resolvedPaths.length} to group ${groupId}`;
        await this.executeWithRetry(script, description);
        if (i < resolvedPaths.length - 1) {
          await delay(500);
        }
      }
    }
  }
  /**
   * Send message to group chat
   */
  async sendToGroup(options) {
    const task = async () => {
      const { groupId, text, attachments = [], signal } = options;
      this.checkAbortSignal(signal);
      try {
        validateChatId(groupId);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        throw SendError(errorMsg);
      }
      let hasText;
      try {
        const validation = validateMessageContent(text, attachments);
        hasText = validation.hasText;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        throw SendError(errorMsg);
      }
      try {
        this.checkAbortSignal(signal);
        await this.checkMessagesEnvironment();
        const paths = await this.prepareAttachments(attachments);
        const sentAt = /* @__PURE__ */ new Date();
        let messagePromise = null;
        if (this.outgoingManager && paths.length > 0) {
          const attachmentName = paths[0]?.split("/").pop();
          messagePromise = new MessagePromise({
            chatId: groupId,
            text,
            attachmentName,
            isAttachment: true,
            sentAt
          });
          this.outgoingManager.add(messagePromise);
        } else if (this.outgoingManager && hasText) {
          messagePromise = new MessagePromise({
            chatId: groupId,
            text,
            isAttachment: false,
            sentAt
          });
          this.outgoingManager.add(messagePromise);
        }
        await this.sendToGroupChat(groupId, text, hasText, paths);
        let confirmedMessage;
        if (messagePromise) {
          try {
            confirmedMessage = await messagePromise.promise;
            if (this.debug) {
              console.log("[Sender] Group message confirmed in database");
            }
          } catch (promiseError) {
            if (this.debug) {
              console.warn("[Sender] Group message promise rejected:", promiseError);
            }
          }
        }
        return { sentAt, message: confirmedMessage };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        const context = `[Group: ${groupId}] [Text: ${hasText ? "yes" : "no"}] [Attachments: ${attachments.length}]`;
        const cause = error instanceof Error ? error : void 0;
        if (error instanceof IMessageError) {
          throw SendError(`${errorMsg} ${context}`, cause);
        }
        throw SendError(`Send failed ${context}: ${errorMsg}`, cause);
      }
    };
    return this.semaphore ? await this.semaphore.run(task) : await task();
  }
};

// src/core/watcher.ts
var MessageWatcher = class {
  constructor(database, pollInterval, unreadOnly, excludeOwnMessages, webhookConfig, events = {}, pluginManager, debug = false, outgoingManager, initialLookbackMs = 1e4) {
    this.database = database;
    this.pollInterval = pollInterval;
    this.unreadOnly = unreadOnly;
    this.excludeOwnMessages = excludeOwnMessages;
    this.webhookConfig = webhookConfig;
    this.events = events;
    this.pluginManager = pluginManager;
    this.debug = debug;
    this.outgoingManager = outgoingManager;
    this.lastCheckTime = new Date(Date.now() - initialLookbackMs);
  }
  /** Whether currently running */
  isRunning = false;
  /** Polling timer ID */
  intervalId = null;
  /** Whether currently checking */
  isChecking = false;
  /** Last check time (for incremental queries) */
  lastCheckTime;
  /** Set of processed message IDs (simple deduplication) */
  seenMessageIds = /* @__PURE__ */ new Map();
  /**
   * Start watching for new messages
   */
  async start() {
    if (this.isRunning) return;
    this.isRunning = true;
    if (this.debug) {
      console.log(`[Watcher] Started (poll interval: ${this.pollInterval}ms)`);
    }
    try {
      await this.check();
    } catch (error) {
      this.isRunning = false;
      throw error;
    }
    this.intervalId = setInterval(() => {
      this.check().catch((error) => {
        this.handleError(error);
      });
    }, this.pollInterval);
  }
  /**
   * Stop watching
   */
  stop() {
    if (!this.isRunning) return;
    this.isRunning = false;
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    if (this.debug) {
      console.log("[Watcher] Stopped");
    }
  }
  /**
   * Check for new messages
   */
  async check() {
    if (this.isChecking) return;
    this.isChecking = true;
    try {
      const overlapMs = Math.min(1e3, this.pollInterval);
      const checkStart = /* @__PURE__ */ new Date();
      const since = new Date(this.lastCheckTime.getTime() - overlapMs);
      const { messages } = await this.database.getMessages({
        since,
        excludeOwnMessages: false
        // Always fetch own messages for outgoing resolution
      });
      this.lastCheckTime = checkStart;
      let newMessages = messages.filter((msg) => !this.seenMessageIds.has(msg.id));
      if (this.outgoingManager) {
        for (const msg of newMessages) {
          if (msg.isFromMe) {
            const matched = this.outgoingManager.tryResolve(msg);
            if (this.debug && matched) {
              console.log(`[Watcher] Resolved outgoing message: ${msg.id}`);
            }
          }
        }
      }
      if (this.unreadOnly) {
        newMessages = newMessages.filter((msg) => !msg.isRead);
      }
      if (this.excludeOwnMessages) {
        newMessages = newMessages.filter((msg) => !msg.isFromMe);
      }
      const now = Date.now();
      for (const msg of newMessages) {
        this.seenMessageIds.set(msg.id, now);
      }
      await Promise.all(
        newMessages.map((msg) => this.handleNewMessage(msg).catch((err) => this.handleError(err)))
      );
      if (this.seenMessageIds.size > 1e4) {
        const hourAgo = now - 36e5;
        for (const [id, timestamp] of this.seenMessageIds.entries()) {
          if (timestamp < hourAgo) {
            this.seenMessageIds.delete(id);
          }
        }
      }
      if (this.outgoingManager) {
        this.outgoingManager.cleanup();
      }
    } catch (error) {
      this.handleError(error);
    } finally {
      this.isChecking = false;
    }
  }
  /**
   * Handle new message
   * Triggers in sequence: Plugin hooks -> Event callback -> Webhook notification
   * @param message New message object
   */
  async handleNewMessage(message) {
    try {
      await this.pluginManager?.callHookForAll("onNewMessage", message);
      await this.events.onMessage?.(message);
      if (message.isGroupChat) {
        await this.events.onGroupMessage?.(message);
      } else {
        await this.events.onDirectMessage?.(message);
      }
      if (this.webhookConfig) await this.sendWebhook(message);
    } catch (error) {
      this.handleError(error);
    }
  }
  /**
   * Send webhook notification
   * POST message data to configured webhook URL
   * @param message Message to notify
   */
  async sendWebhook(message) {
    if (!this.webhookConfig) return;
    const retries = this.webhookConfig.retries ?? 0;
    const backoffMs = this.webhookConfig.backoffMs ?? 0;
    let lastError = null;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const response = await fetch(this.webhookConfig.url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...this.webhookConfig.headers
          },
          body: JSON.stringify({
            event: "new_message",
            message: {
              id: message.id,
              text: message.text,
              sender: message.sender,
              senderName: message.senderName,
              isRead: message.isRead,
              service: message.service,
              hasAttachments: message.attachments.length > 0,
              attachments: message.attachments.map((a) => ({
                filename: a.filename,
                mimeType: a.mimeType,
                size: a.size,
                isImage: a.isImage
              })),
              date: message.date.toISOString()
            },
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }),
          signal: AbortSignal.timeout(this.webhookConfig.timeout || 5e3)
        });
        if (!response.ok) {
          throw WebhookError(`Webhook failed with status ${response.status}`);
        }
        return;
      } catch (error) {
        lastError = error;
        if (attempt < retries && backoffMs > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, backoffMs));
        }
      }
    }
    throw WebhookError(
      `Failed to send webhook: ${lastError instanceof Error ? lastError.message : String(lastError ?? "unknown error")}`
    );
  }
  /**
   * Unified error handling
   * Output error to console and trigger error callback
   * @param error Error object of any type
   */
  handleError(error) {
    const err = error instanceof Error ? error : new Error(String(error));
    if (this.debug) {
      console.error("[Watcher] Error:", err);
    }
    this.events.onError?.(err);
  }
};

// src/core/sdk.ts
var IMessageSDK = class {
  /** Configuration */
  config;
  /** Database */
  database;
  /** Temporary file manager */
  tempFileManager;
  /** Message sender */
  sender;
  /** Plugin manager */
  pluginManager;
  /** Message watcher */
  watcher = null;
  /** Outgoing message manager */
  outgoingManager;
  /** Whether destroyed */
  destroyed = false;
  constructor(config = {}, dependencies) {
    requireMacOS();
    this.config = this.resolveConfig(config);
    this.database = dependencies?.database ?? new IMessageDatabase(this.config.databasePath);
    this.tempFileManager = new TempFileManager({
      maxAge: this.config.tempFile?.maxAge,
      cleanupInterval: this.config.tempFile?.cleanupInterval,
      debug: this.config.debug
    });
    this.tempFileManager.start();
    this.sender = dependencies?.sender ?? new MessageSender(
      this.config.debug,
      this.config.retry,
      this.config.maxConcurrent,
      this.config.scriptTimeout
    );
    this.pluginManager = dependencies?.pluginManager ?? new PluginManager();
    this.outgoingManager = new OutgoingMessageManager(this.config.debug);
    if ("setOutgoingManager" in this.sender && typeof this.sender.setOutgoingManager === "function") {
      this.sender.setOutgoingManager(this.outgoingManager);
    }
    if (config.plugins) {
      for (const plugin of config.plugins) {
        this.pluginManager.use(plugin);
      }
    }
    if (this.config.debug) {
      console.log("[SDK] Initialization complete");
    }
  }
  async ensurePluginsReady() {
    if (!this.pluginManager.initialized) {
      await this.pluginManager.init();
    }
  }
  resolveConfig(config) {
    const clamp = (v, min, max, def) => {
      const val = v ?? def;
      if (val < min || val > max) {
        throw new Error(`Value must be between ${min} and ${max}`);
      }
      return val;
    };
    return {
      databasePath: config.databasePath ?? getDefaultDatabasePath(),
      webhook: config.webhook ?? null,
      watcher: {
        pollInterval: clamp(config.watcher?.pollInterval, 100, 6e4, 2e3),
        unreadOnly: config.watcher?.unreadOnly ?? false,
        excludeOwnMessages: config.watcher?.excludeOwnMessages ?? true
      },
      retry: {
        max: clamp(config.retry?.max, 0, 10, 2),
        delay: clamp(config.retry?.delay, 0, 1e4, 1500)
      },
      tempFile: {
        maxAge: clamp(config.tempFile?.maxAge, 6e4, 36e5, 6e5),
        // 1 minute ~ 1 hour, default 10 minutes
        cleanupInterval: clamp(config.tempFile?.cleanupInterval, 6e4, 18e5, 3e5)
        // 1 minute ~ 30 minutes, default 5 minutes
      },
      scriptTimeout: clamp(config.scriptTimeout, 5e3, 12e4, 3e4),
      // 5 seconds ~ 2 minutes, default 30 seconds
      maxConcurrent: clamp(config.maxConcurrent, 0, 50, 5),
      debug: config.debug ?? false
    };
  }
  /**
   * Determine if a string is a chatId (not a recipient)
   *
   * ChatId formats:
   * - Group GUID: `chat123...`
   * - AppleScript group: `iMessage;+;chat123...`
   *
   * Recipient formats:
   * - Phone: `+1234567890`
   * - Email: `user@example.com`
   *
   * Note: `iMessage;+1234567890` is NOT a chatId for routing purposes.
   * It's a service-prefixed recipient that should be sent via buddy method.
   */
  isChatId(value) {
    if (isGroupChatId(value)) {
      return true;
    }
    try {
      asRecipient(value);
      return false;
    } catch {
      const extracted = extractRecipientFromChatId(value);
      if (extracted) {
        return false;
      }
      return true;
    }
  }
  /**
   * Register plugin
   */
  use(plugin) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    this.pluginManager.use(plugin);
    return this;
  }
  /**
   * Get plugin manager
   * @returns PluginManager instance
   */
  get plugins() {
    return this.pluginManager;
  }
  /**
   * Query messages
   */
  async getMessages(filter) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    await this.ensurePluginsReady();
    await this.pluginManager.callHookForAll("onBeforeQuery", filter);
    const result = await this.database.getMessages(filter);
    await this.pluginManager.callHookForAll("onAfterQuery", result.messages);
    return result;
  }
  /**
   * Get unread messages (grouped by sender)
   *
   * @returns Unread messages with statistics
   * @example
   * ```ts
   * const unread = await sdk.getUnreadMessages()
   * console.log(`${unread.total} unread messages from ${unread.senderCount} senders`)
   * for (const { sender, messages } of unread.groups) {
   *   console.log(`${sender}: ${messages.length} messages`)
   * }
   * ```
   */
  async getUnreadMessages() {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    await this.ensurePluginsReady();
    await this.pluginManager.callHookForAll("onBeforeQuery", { unreadOnly: true });
    const { grouped, total } = await this.database.getUnreadMessages();
    const groups = Array.from(grouped.entries()).map(([sender, messages]) => ({
      sender,
      messages
    }));
    const result = {
      groups,
      total,
      senderCount: groups.length
    };
    const allMessages = groups.flatMap((g) => g.messages);
    await this.pluginManager.callHookForAll("onAfterQuery", allMessages);
    return result;
  }
  /**
   * Send message to recipient (phone/email) or chat (chatId)
   *
   * Automatically detects whether the target is:
   * - A recipient (phone number or email): e.g., '+1234567890', 'user@example.com'
   * - A chatId (group or DM): e.g., 'chat123...', 'iMessage;+1234567890'
   *
   * @example
   * ```ts
   * // Send to phone number
   * await sdk.send('+1234567890', 'Hello')
   *
   * // Send to email
   * await sdk.send('user@example.com', 'Hello')
   *
   * // Send to group chat
   * await sdk.send('chat123...', 'Hello')
   *
   * // Send with attachments
   * await sdk.send('+1234567890', { images: ['/img.jpg'] })
   * await sdk.send('chat123...', { text: 'Hi', files: ['/doc.pdf'] })
   * ```
   */
  async send(to, content) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    const normalized = typeof content === "string" ? { text: content, attachments: [] } : {
      text: content.text,
      attachments: [...content.images || [], ...content.files || []]
    };
    const target = String(to);
    const isChatIdTarget = this.isChatId(target);
    if (isChatIdTarget) {
      validateChatId(target);
      await this.ensurePluginsReady();
      await this.pluginManager.callHookForAll("onBeforeSend", target, {
        text: normalized.text,
        attachments: normalized.attachments
      });
      const result2 = await this.sender.sendToGroup({
        groupId: target,
        text: normalized.text,
        attachments: normalized.attachments
      });
      await this.pluginManager.callHookForAll("onAfterSend", target, result2);
      return result2;
    }
    const extracted = extractRecipientFromChatId(target);
    const recipient = extracted || asRecipient(target);
    const chatId = target.includes(";") ? target : `iMessage;${recipient}`;
    await this.ensurePluginsReady();
    await this.pluginManager.callHookForAll("onBeforeSend", chatId, {
      text: normalized.text,
      attachments: normalized.attachments
    });
    const result = await this.sender.send({
      to: recipient,
      text: normalized.text,
      attachments: normalized.attachments
    });
    await this.pluginManager.callHookForAll("onAfterSend", chatId, result);
    return result;
  }
  /**
   * List chats with filtering and sorting options
   *
   * @param options Filter and sort options (or a number for backward compatibility)
   * @returns Array of chat summaries with unread counts
   *
   * @example
   * ```ts
   * // Get all chats
   * const all = await sdk.listChats()
   *
   * // Get recent group chats with unread messages
   * const groups = await sdk.listChats({
   *   type: 'group',
   *   hasUnread: true,
   *   limit: 20
   * })
   *
   * // Search chats by name
   * const found = await sdk.listChats({
   *   search: 'John',
   *   sortBy: 'name'
   * })
   *
   * // Backward compatible: limit only
   * const recent = await sdk.listChats({ limit: 50 })
   * ```
   */
  async listChats(options) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    await this.ensurePluginsReady();
    const opts = typeof options === "number" ? { limit: options } : options || {};
    await this.pluginManager.callHookForAll("onBeforeQuery", opts);
    const result = await this.database.listChats(opts);
    await this.pluginManager.callHookForAll("onAfterQuery", []);
    return result;
  }
  /**
   * Send batch messages (concurrency controlled by sender's maxConcurrent config)
   *
   * @param messages Batch message list
   * @returns List of send results (including success and failure)
   *
   * @example
   * ```ts
   * const results = await sdk.sendBatch([
   *   { to: '+1234567890', content: 'Hello' },
   *   { to: '+0987654321', content: 'Hi' },
   * ])
   *
   * for (const result of results) {
   *   if (result.success) {
   *     console.log('Send success:', result.to)
   *   } else {
   *     console.error('Send failed:', result.to, result.error)
   *   }
   * }
   * ```
   */
  async sendBatch(messages) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    const results = await Promise.allSettled(
      messages.map(async ({ to, content }) => ({
        to: String(to),
        result: await this.send(to, content)
      }))
    );
    return results.map((result, index) => {
      const to = String(messages[index].to);
      if (result.status === "fulfilled") {
        return {
          to,
          success: true,
          result: result.value.result
        };
      }
      return {
        to,
        success: false,
        error: result.reason instanceof Error ? result.reason : new Error(String(result.reason))
      };
    });
  }
  /**
   * Send file (convenience method)
   *
   * Supports both recipient (phone/email) and chatId
   *
   * @example
   * ```ts
   * // Send to phone number
   * await sdk.sendFile('+1234567890', '/path/to/document.pdf')
   *
   * // Send to group chat
   * await sdk.sendFile('chat123...', '/path/to/document.pdf', 'Here is the file')
   * ```
   */
  async sendFile(to, filePath, text) {
    return this.send(to, { text, files: [filePath] });
  }
  /**
   * Send multiple files (convenience method)
   *
   * Supports both recipient (phone/email) and chatId
   *
   * @example
   * ```ts
   * // Send to phone number
   * await sdk.sendFiles('+1234567890', ['/file1.pdf', '/file2.csv'])
   *
   * // Send to group chat
   * await sdk.sendFiles('chat123...', ['/data.xlsx'], 'Check these files')
   * ```
   */
  async sendFiles(to, filePaths, text) {
    return this.send(to, { text, files: filePaths });
  }
  // ==================== Message Chain Processing ====================
  /**
   * Create message processing chain
   */
  message(message) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    return new MessageChain(message, this.sender);
  }
  /**
   * Start watching for new messages
   */
  async startWatching(events) {
    if (this.destroyed) throw new Error(ERROR_SDK_DESTROYED);
    if (this.watcher) throw new Error(ERROR_WATCHER_RUNNING);
    const watcher = new MessageWatcher(
      this.database,
      this.config.watcher.pollInterval,
      this.config.watcher.unreadOnly,
      this.config.watcher.excludeOwnMessages,
      this.config.webhook,
      events,
      this.pluginManager,
      this.config.debug,
      this.outgoingManager
    );
    try {
      await watcher.start();
      this.watcher = watcher;
    } catch (error) {
      watcher.stop();
      throw error;
    }
  }
  /**
   * Stop watching for new messages
   */
  stopWatching() {
    this.watcher?.stop();
    this.watcher = null;
  }
  /**
   * Close SDK and release resources
   */
  async close() {
    if (this.destroyed) return;
    this.destroyed = true;
    const errors = [];
    try {
      this.watcher?.stop();
    } catch (error) {
      errors.push({
        component: "watcher",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    this.watcher = null;
    try {
      this.outgoingManager.rejectAll("SDK closed");
    } catch (error) {
      errors.push({
        component: "outgoingManager",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    try {
      await this.pluginManager.destroy();
    } catch (error) {
      errors.push({
        component: "pluginManager",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    try {
      await this.tempFileManager.destroy();
    } catch (error) {
      errors.push({
        component: "tempFileManager",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    try {
      this.database.close();
    } catch (error) {
      errors.push({
        component: "database",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    if (errors.length > 0) {
      if (this.config.debug) {
        console.error("[SDK] Error occurred during shutdown:", errors);
      }
      if (typeof AggregateError !== "undefined") {
        throw new AggregateError(
          errors.map((e) => e.error),
          `SDK shutdown failed: ${errors.map((e) => e.component).join(", ")}`
        );
      }
      throw errors[0].error;
    }
  }
  /** Support using declaration (TypeScript 5.2+) */
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  /** Support using declaration (sync version) */
  [Symbol.dispose]() {
    this.close().catch(console.error);
  }
};

// src/plugins/logger.ts
var LEVELS = { debug: 0, info: 1, warn: 2, error: 3 };
var COLORS = {
  debug: "\x1B[36m",
  info: "\x1B[32m",
  warn: "\x1B[33m",
  error: "\x1B[31m"
};
var RESET = "\x1B[0m";
var loggerPlugin = (options = {}) => {
  const { level = "info", colored = true, timestamp = false, logSend = true, logNewMessage = false } = options;
  const log = (logLevel, message, data) => {
    if (LEVELS[logLevel] < LEVELS[level]) return;
    const time = timestamp ? (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US") : "";
    const tag = logLevel.toUpperCase().padEnd(5);
    const color = colored ? COLORS[logLevel] : "";
    const reset = colored ? RESET : "";
    const prefix = time ? `${time} ${color}[${tag}]${reset}` : `${color}[${tag}]${reset}`;
    const output = `${prefix} ${message}`;
    console.log(output);
  };
  return definePlugin({
    name: "logger",
    version: "1.0.0",
    description: "Logger plugin",
    onInit: () => {
      log("info", "SDK initialized");
    },
    onBeforeSend: (to, content) => {
      if (!logSend) return;
      const preview = content.text?.substring(0, 30) || "(no text)";
      const attachCount = content.attachments?.length || 0;
      const attachInfo = attachCount ? ` + ${attachCount} attachment(s)` : "";
      log("info", `[SEND] Sending to ${to}: ${preview}${attachInfo}`);
    },
    onAfterSend: (to) => {
      if (logSend) {
        log("info", `[OK] Sent successfully -> ${to}`);
      }
    },
    onNewMessage: (message) => {
      if (!logNewMessage) return;
      const preview = message.text?.substring(0, 40) || "(no text)";
      const attachCount = message.attachments.length;
      const attachInfo = attachCount ? ` [${attachCount}]` : "";
      log("info", `[MSG] New message from ${message.sender}: ${preview}${attachInfo}`);
    },
    onError: (error, context) => {
      const contextInfo = context || "Error";
      log("error", `[ERROR] ${contextInfo}: ${error.message}`);
    },
    onDestroy: () => {
      log("info", "[CLOSE] SDK destroyed");
    }
  });
};
var IMAGE_EXTENSIONS = ["jpg", "jpeg", "png", "gif", "heic", "heif", "webp", "bmp", "tiff", "svg"];
var VIDEO_EXTENSIONS = ["mp4", "mov", "avi", "mkv", "m4v", "wmv", "flv", "webm"];
var AUDIO_EXTENSIONS = ["mp3", "m4a", "wav", "aac", "flac", "ogg", "wma"];
async function attachmentExists(attachment) {
  try {
    await fs.promises.access(attachment.path, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}
async function downloadAttachment(attachment, destPath) {
  const destDir = path.dirname(destPath);
  await fs.promises.mkdir(destDir, { recursive: true });
  await fs.promises.copyFile(attachment.path, destPath);
}
async function getAttachmentSize(attachment) {
  try {
    const stats = await fs.promises.stat(attachment.path);
    return stats.size;
  } catch {
    return 0;
  }
}
async function getAttachmentMetadata(attachment) {
  try {
    return await fs.promises.stat(attachment.path);
  } catch {
    return null;
  }
}
async function readAttachment(attachment) {
  return await fs.promises.readFile(attachment.path);
}
function getAttachmentExtension(attachment) {
  const ext = path.extname(attachment.path);
  return ext ? ext.slice(1).toLowerCase() : "";
}
function isImageAttachment(attachment) {
  const ext = getAttachmentExtension(attachment);
  return IMAGE_EXTENSIONS.includes(ext);
}
function isVideoAttachment(attachment) {
  const ext = getAttachmentExtension(attachment);
  return VIDEO_EXTENSIONS.includes(ext);
}
function isAudioAttachment(attachment) {
  const ext = getAttachmentExtension(attachment);
  return AUDIO_EXTENSIONS.includes(ext);
}

export { ConfigError, DatabaseError, IMessageError, IMessageSDK, MessageChain, PlatformError, SendError, WebhookError, asRecipient, attachmentExists, definePlugin, downloadAttachment, getAttachmentExtension, getAttachmentMetadata, getAttachmentSize, isAudioAttachment, isImageAttachment, isMacOS, isVideoAttachment, loggerPlugin, readAttachment, requireMacOS };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map